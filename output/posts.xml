<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://www.zuttonet.com/</id>
  <title>The Dump</title>
  <updated>2011-07-15T06:00:00Z</updated>
  <link rel="alternate" href="http://www.zuttonet.com/"/>
  <link rel="self" href="http://www.zuttonet.com/posts.xml"/>
  <author>
    <name>Ryan</name>
    <uri>http://www.zuttonet.com</uri>
  </author>
  <entry>
    <id>tag:www.zuttonet.com,2011-07-15:/articles/anonymous-functions-and-closure-php/</id>
    <title type="html">Anonymous functions and closure in PHP</title>
    <published>2011-07-15T06:00:00Z</published>
    <updated>2011-07-15T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/anonymous-functions-and-closure-php/"/>
    <content type="html">&lt;p&gt;According to Wikipedia, a &lt;strong&gt;closure&lt;/strong&gt; is a&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;function together with a referencing environment for the nonlocal names (free variables) of that function&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Such a function is said to be &lt;em&gt;closed over&lt;/em&gt; its free variables. These free variables, or &lt;em&gt;upvalues&lt;/em&gt;, come from the enclosing scope of the anonymous function and persist even when the stack frame that introduced them is destroyed.&lt;/p&gt;
&lt;p&gt;What does this mean for us, as &lt;span class="caps"&gt;PHP&lt;/span&gt; developers? If you&amp;#8217;re using function literals to assign anonymous functions to named variables, then not much. You can already do this, to some extent, by using the much-maligned &lt;code&gt;global&lt;/code&gt; keyword to import variable references from the global scope. In any &lt;em&gt;other&lt;/em&gt; context, however, closures are a powerfully expressive means for performing many otherwise tedious and complicated tasks.&lt;/p&gt;
&lt;p&gt;First, let&amp;#8217;s walk through an example of using the &lt;code&gt;global&lt;/code&gt; keyword in a function defined in the global namespace (or a method defined in a class in the global namespace) as a basis for comparison against the closures we&amp;#8217;ll talk about momentarily.&lt;/p&gt;
&lt;p&gt;Suppose you are writing a function that, for some &lt;em&gt;good&lt;/em&gt; reason, requires you to change a variable defined outside of the function&amp;#8217;s scope. We can import the global variable into the function scope using the &lt;code&gt;global&lt;/code&gt; keyword, like so:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=basic-global.php"&gt;&lt;/script&gt;&lt;p&gt;The output of this script would be &lt;code&gt;1&lt;/code&gt;. The function body imports the reference to the global variable &lt;code&gt;$count&lt;/code&gt;, whose value at that time is &lt;code&gt;0&lt;/code&gt;. The global variable itself is then incremented. So, this function actually modifies something in the global namespace.&lt;/p&gt;
&lt;p&gt;A naive reading of the definition of &lt;em&gt;closure&lt;/em&gt; above might lead one to think that this fits the definition. Upon further inspection, the implementation details are slightly different; &lt;span class="caps"&gt;PHP&lt;/span&gt; has a superglobal variable named &lt;code&gt;$GLOBALS&lt;/code&gt; that is accessible from within any scope. The construct &lt;code&gt;global $var&lt;/code&gt; is simply syntactic sugar for the uglier expression &lt;code&gt;$var = &amp;amp;$GLOBALS['var'];&lt;/code&gt;, which would have the same effect. This is not closure.&lt;/p&gt;
&lt;p&gt;Another reason this does not create closure is due to the fact that, no matter what scope you are currently within, &lt;code&gt;global&lt;/code&gt; imports only from the global namespace (due to the implementation reality outlined above). For example, a function within a function cannot import scope from its parent, but only from the global namespace.&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=global-inner-function.php"&gt;&lt;/script&gt;&lt;p&gt;Running the program above will output &lt;code&gt;11&lt;/code&gt;. This shows that global imports variables only from the global namespace, not just from the &amp;#8220;parent&amp;#8221; namespace. Closure would require either the &lt;code&gt;global&lt;/code&gt; statement to work as just described, or simply allow the parent scope to creep into the child scope (another style of scoping entirely, a la javascript). This is not closure.&lt;/p&gt;
&lt;p&gt;Is an anonymous function a closure, then? Anonymous functions and closures are often conflated, but they are distinct concepts. I think the garden path I&amp;#8217;ve been leading you on so far should have steered you away from this, but let&amp;#8217;s just make sure. We know that simply using &lt;code&gt;global&lt;/code&gt; isn&amp;#8217;t closure because of its implementation-that it doesn&amp;#8217;t actually close over variables within the function-defining scope, it just brings them into the current scope by reference.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m not exactly sure about the low-level implementation details of functions versus anonymous functions in &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3, but as far as I know there is no meaningful difference in terms of the ostensible constraints they face in terms of scope, input, and output. For example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=function-literal-global.php"&gt;&lt;/script&gt;&lt;p&gt;The only meaningful difference here is that &lt;code&gt;increase_count&lt;/code&gt; is given a name at define-time, while &lt;code&gt;$increase_count_again&lt;/code&gt; is assigned a function literal which is executed by name at run time. They both face the same rules &lt;em&gt;vis-a-vis&lt;/em&gt; &lt;code&gt;global&lt;/code&gt;, and the fact that this script will output &lt;code&gt;2&lt;/code&gt; is proof of that.&lt;/p&gt;
&lt;p&gt;So what is closure? You&amp;#8217;ve been reading long enough now that you might suspect I&amp;#8217;ve eliminated every possible misconception that could possible arise. That&amp;#8217;s not true; closure is a difficult concept to grasp, and misunderstanding it can lead to misuse, which can introduce hard-to-detect bugs.&lt;/p&gt;
&lt;p&gt;Closure requires both a function, which creates its own scope, and a surrounding environment which persists through an arbitrary number of executions of that function. So, an anonymous function is insufficient; it satisfies only the first part of this requirement. In order to produce a closure, we need to be able to create the surrounding environment. Luckily, &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3 also introduced a very useful construct for turning anonymous functions into closures.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;use&lt;/code&gt; keyword, when paired with a function literal, or anonymous function, allows us to import variable values or references into the scope of the function. Here&amp;#8217;s an example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=simple-naive-closure-value.php"&gt;&lt;/script&gt;&lt;p&gt;We are importing &lt;code&gt;$count&lt;/code&gt; by value, so the output of the script is &lt;code&gt;1&lt;/code&gt;. This is because we are taking the value of &lt;code&gt;$count&lt;/code&gt; at the time the function literal is defined and initializing a new variable in our function to refer to that value. Even if we change the value of &lt;code&gt;$count&lt;/code&gt; (say, by incrementing it between defining &lt;code&gt;$decrease_count&lt;/code&gt; and calling it), it is now bound to &lt;code&gt;1&lt;/code&gt; within the function body. This also implies that changing &lt;code&gt;$count&lt;/code&gt; in the function body will have no effect on its enclosing scope. This is not closure.&lt;/p&gt;
&lt;p&gt;More basically, how is this any different from using &lt;code&gt;global&lt;/code&gt; inside a function defined in the global namespace? The most important way is that it allows us to import a value or reference from the immediate-parent scope, not just the global scope. The tuple following the &lt;code&gt;use&lt;/code&gt; keyword tells &lt;span class="caps"&gt;PHP&lt;/span&gt; to import values or references to each element into the function scope.&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=simple-naive-closure-reference.php"&gt;&lt;/script&gt;&lt;p&gt;I keep using the term &amp;#8220;values or reference&amp;#8221; because either is possible. Notice in the example above that I have prefixed &lt;code&gt;$count&lt;/code&gt; with &lt;code&gt;&amp;amp;&lt;/code&gt;, the &lt;span class="caps"&gt;PHP&lt;/span&gt; symbol that reds &amp;#8220;by reference.&amp;#8221; The output of the above script is as expected; &lt;code&gt;$count&lt;/code&gt; is decremented and the result is &lt;code&gt;0&lt;/code&gt;. Notice that this particular script need not be defined in the global namespace (the file in which it&amp;#8217;s defined could be included in a function, for example); &lt;code&gt;use&lt;/code&gt; always refers to the scope in which the function is defined. This is closure.&lt;/p&gt;
&lt;p&gt;Ok, so we can import variables by reference into our anonymous functions. What&amp;#8217;s the big deal? Well, now that we understand many of the things that &lt;em&gt;aren&amp;#8217;t&lt;/em&gt; closure (and have an example of something that technically &lt;em&gt;is&lt;/em&gt; closure), let&amp;#8217;s see what we can do with it.&lt;/p&gt;
&lt;p&gt;Strictly speaking, the information that is created inside of a function body is lost when that function&amp;#8217;s execution is completed, because the frame containing it is popped off the stack (although this &lt;a href="http://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope"&gt;isn&amp;#8217;t exactly right&lt;/a&gt;). Within a closure, however, we can maintain and manipulate the information created inside of an enclosing function. Check out the following example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=full-closure-count.php"&gt;&lt;/script&gt;&lt;p&gt;In this script, the body of the &lt;code&gt;create_closure&lt;/code&gt; function has a local variable named &lt;code&gt;$count&lt;/code&gt;. &lt;code&gt;create_closure&lt;/code&gt; returns an anonymous function which has by-reference access to this local variable. Therefore, where @create_closure@&amp;#8217;s &lt;code&gt;$count&lt;/code&gt; would typically lose all references when its body was finished executing, now there remains a reference to it in any variable to which the anonymous function is assigned. &lt;strong&gt;&lt;code&gt;create_closure&lt;/code&gt; creates a closure because it returns a function together with a referencing environment for the nonlocal names of that function&lt;/strong&gt;. This is closure.&lt;/p&gt;
&lt;p&gt;Notice the output of the above. We call the anonymous function three times, and the output changes each time, even though the body of the anonymous function really does nothing interesting. &lt;code&gt;$closure&lt;/code&gt; has &amp;#8220;closed over&amp;#8221; &lt;code&gt;$count&lt;/code&gt; and now has local access to it for any call to &lt;code&gt;$closure()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What if we generate multiple closures; how is this handled? I&amp;#8217;m so glad you asked.&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=full-closure-count-2.php"&gt;&lt;/script&gt;&lt;p&gt;We are now creating two versions of the closure. You noticed, of course, that the function generating the closures is parameterized by &lt;code&gt;$count&lt;/code&gt;. Since we are calling this function twice&amp;#8212;with a different parameter value each time&amp;#8212;it shouldn&amp;#8217;t come as a surprise that we will be receiving two separate closures, each closed over a different value for &lt;code&gt;$count&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Anonymous functions and closures are a very neat and powerful addition to &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3. I hope after reading this article you better understand how to use these new language features, and maybe even have a better idea of why they&amp;#8217;re a big improvement over what was previously available. This article is meant to serve as a basic introduction and overview of the language-level characteristics of closures. Let me know what you think!&lt;/p&gt;</content>
    <summary type="html">PHP 5.3 introduces function literals to the language, which gives us some big benefits when using functions that accept other functions as arguments (typically as a callback). However, anonymous functions were paired with another useful language construct which allows us to close over variables in the same lexical scope as the anonymous function, creating a closure.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-06-13:/articles/dead-simple-profiling-in-php/</id>
    <title type="html">Dead simple performance profiling in PHP 5.3</title>
    <published>2011-06-13T06:00:00Z</published>
    <updated>2011-06-13T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/dead-simple-profiling-in-php/"/>
    <content type="html">&lt;p&gt;As of &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3, we have access to anonymous functions (closures) in our code. This makes it pretty easy to wrap scope and functionality into a nice, neat little package and feed it to a utility function to do with it what it will (instead of responding only at runtime). So I wrote a function, called &lt;code&gt;profile&lt;/code&gt;, which accepts a diagnostic messge and a closure which should include the code you are interested in profiling.&lt;/p&gt;
&lt;script src="https://gist.github.com/1025970.js?file=profile.php"&gt;&lt;/script&gt;&lt;p&gt;All this function does is record the current time in microseconds, run the callback you passed, check the time again, and then return a string representation of the execution time. Simple enough, right!? I had a hard time finding something suitably simple, though. Here&amp;#8217;s an example of it in action:&lt;/p&gt;
&lt;script src="https://gist.github.com/1025970.js?file=simple_test.php"&gt;&lt;/script&gt;&lt;p&gt;The world of performance profiling is now your oyster. Of course, this approach is limited by the implementation details of closures. For example, if you want to globalize variables from a broader scope to use in your closure, you&amp;#8217;ll have to import them using the &lt;code&gt;use&lt;/code&gt; keyword in the closure definition.&lt;/p&gt;
&lt;p&gt;This could also be broadened a bit by wrapping the profile function up into a profiling class that would save information about various closure executions. Furthermore, I make a pretty bold assumption about how I wanted the information about the execution time returned back to me; this could certainly use some abstraction. Sounds like a good evening project!&lt;/p&gt;</content>
    <summary type="html">I often find myself wondering which way to do things is best. Of course, PHP's library makes it pretty easy to whip up a quick set of timing functions to wrap around your code. It's disconcerting to me, however, to make two function calls and call it good. Maybe I'm jaded by the prevalence of blocks in ruby, but I would love to see that my profiling code is getting everything I want and _only_ those things I want. So I decided to (finally?) sit down and whip up something quick and simple to alleviate my neurosis.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-06-07:/articles/setting-up-a-nanoc-website/</id>
    <title type="html">Setting up a nanoc website (compilation and rules)</title>
    <published>2011-06-07T06:00:00Z</published>
    <updated>2011-06-07T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/setting-up-a-nanoc-website/"/>
    <content type="html">&lt;p&gt;The first thing that tripped me up about nanoc was how best to handle my images and other binary files. I think the documentation talks about binary files a bit, but I was left a little confused even after several reads through. I knew that the standard nanoc metadata couldn&amp;#8217;t simply be added to the top of the file, but I had trouble figuring out how to get the files where I wanted them to go. A little trial and error helped, but the biggest breakthrough came after I worked with the process as a whole. Below is an example of my compilation and routing rules for my basic images:&lt;/p&gt;
&lt;p&gt;Basically, the nanoc process consists of two steps: compilation and routing. Compilation, the way I see it, is the process of taking particular items (in the nanoc nomenclature) and transforming their contents according to specific rules that you create. To help you out, nanoc provides a bunch of built-in helpers and filters while exposing a simple api for accessing each item as it&amp;#8217;s given. Compilation can be as complicated as translating into another language (or something) or as simple as passing the content through. The articles on this site, for example, are simply passed through RedCloth (a Ruby textile implementation) and returned.&lt;/p&gt;
&lt;p&gt;After all of the items are compiled and linked, they&amp;#8217;re routed. Routing is the process of actually putting the compiled files where they need to go. Routing rules match item identifiers (in the same way that compilation rules do) and allow you to return a string different than the identifier, in which case the item will be placed in &lt;code&gt;/output/&lt;/code&gt; accordingly. Routing &lt;code&gt;/foo/&lt;/code&gt; to &lt;code&gt;/pages/foo/&lt;/code&gt; for example, will cause the output file to be placed in &lt;code&gt;/pages/foo/index.html&lt;/code&gt; instead of &lt;code&gt;/foo/index.html&lt;/code&gt; by default. One could also route &lt;code&gt;/foo/&lt;/code&gt; to &lt;code&gt;/foo.html&lt;/code&gt; if one wanted. The routing rule is given the item object to work with, which includes data about the identifier, the path, the extension, and other things.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s an example of the compilation and routing rules I use for the index page and the articles for this website:&lt;/p&gt;
&lt;script src="https://gist.github.com/1012755.js?file=compile_and_route_articles.rb"&gt;&lt;/script&gt;&lt;p&gt;So, back to images: images need no compilation. In fact, we need to prevent any sort of compilation from being done to them. The easiest way to do this is to set up an empty rule; a rule block that does nothing. Next, we need to route the images to their final destination. In my situation, I wanted to be able to access all of my images with a route (or absolute &lt;span class="caps"&gt;URI&lt;/span&gt;) that resembled &lt;code&gt;"/images/name.ext"&lt;/code&gt;. Easy enough-I set up a rule that routes all files in the &lt;code&gt;/content/images&lt;/code&gt; directory of my nanoc install to &lt;code&gt;/output/images/name.ext&lt;/code&gt; (including any subdirectory names).&lt;/p&gt;
&lt;p&gt;Here are the compilation and routing rules I use for basic images on this website:&lt;/p&gt;
&lt;script src="https://gist.github.com/1012755.js?file=compile_and_route_images.rb"&gt;&lt;/script&gt;&lt;p&gt;Looking at the routing rules, it might seem like nanoc is just wasting time-after all, why would I not just put the files in the output structure that I want to begin with? The real value in the routing defaults, as I see it, is that nanoc prefers to rename files to &lt;code&gt;index.html&lt;/code&gt; and place them in a subdirectory that corresponds to the old filename. This is useful, because instead of having to type a url like: &lt;code&gt;zuttonet.com/pages/contact.html&lt;/code&gt;, you can simply make your request for &lt;code&gt;zuttonet.com/pages/contact&lt;/code&gt; instead (provided that &lt;code&gt;index.html&lt;/code&gt; is set as your web server&amp;#8217;s default file to serve when a subdirectory is accessed). Since the content-type of &lt;code&gt;text/html&lt;/code&gt; is all but implicit when making a page request from a web browser, it makes little sense to require your users to type it every single time. Furthermore, when a non-browser user-agent makes the request, they can request a different content-type and be served a different file &lt;em&gt;even from the same request&lt;/em&gt;. Pretty cool!&lt;/p&gt;</content>
    <summary type="html">nanoc is a wonderful little program that allows you to use Ruby/ERB to create statically-generated websites. It saves you the trouble--commonplace among CMS that require database access--of connecting to your database on every request while still allowing you the flexibility of Ruby to generate your sites. This article is a quick walkthrough to bridge the gap between what I learned through the nanoc documentation and what I needed to know to finish converting my own site.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-04-07:/articles/late-game-unit-testing/</id>
    <title type="html">Late-game unit testing</title>
    <published>2011-04-07T06:00:00Z</published>
    <updated>2011-04-07T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/late-game-unit-testing/"/>
    <content type="html">&lt;p&gt;I&amp;#8217;ve struggled with this issue recently as I go back and add tests to &lt;a href="http://www.github.com/rgantt/sake"&gt;sake&lt;/a&gt;, my php mvc framework. I&amp;#8217;ve been using the software on enough sites&amp;#8212;albeit smallish ones&amp;#8212;to know that the core functionality is working as intended. When I encounter an error during development of a site, I revisit the sake repository and update where necessary. I do functional tests to ensure that I haven&amp;#8217;t introduced any obvious regressions, and then I continue to hack happily on the original site. There are several problems with this sort of approach, however. First, even though functional tests don&amp;#8217;t expose any obvious regressions, this is certainly not sufficient evidence to conclude with any confidence that there &lt;em&gt;actually&lt;/em&gt; weren&amp;#8217;t any regressions. I really don&amp;#8217;t know whether my routing and request-reading code response the same way to all meaningful input combinations that they did before. I only know that they &lt;em&gt;probably&lt;/em&gt; respond identically to &lt;em&gt;those input combinations I was already using.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The second problem is that such &lt;em&gt;ad hoc&lt;/em&gt; changes&amp;#8212;even though they aren&amp;#8217;t, strictly speaking, feature additions&amp;#8212;can have an impact on the framework in general. Modifying framework code in response to bugs exposed on an implementation of that framework can be subversive. Since I am developing both the site and the framework, I may, even with the best of intentions, apply changes that fix the solution for my current purposes, but leave it exposed in general. My incentives are misaligned because of the duality of my role at the time. A healthy suite of unit tests would, in this situation, act as a set of guardrails against such behavior. They would keep me honest.&lt;/p&gt;
&lt;p&gt;Ultimately, this is not intended to be an article about the merits of unit testing. We&amp;#8217;ve all been well-indoctrinated in matters of &lt;span class="caps"&gt;TDD&lt;/span&gt;; the question I&amp;#8217;m wrestling with is what unit tests to &lt;em&gt;start&lt;/em&gt; with when you&amp;#8217;re dealing with an already-completed piece of software that you want to harden against regression. This is inherently a short run concept; in the long run, you&amp;#8217;ll either have full test coverage for your current functionality, or you&amp;#8217;ll be left with a dead piece of software and, maybe, revisiting this article!&lt;/p&gt;
&lt;p&gt;In general, I favor any solution to a problem where the progression tends from simplest to most complicated. In the context of unit testing, this implies that I prefer to write tests that cover the simplest, most basic functionality first. Why not? Approaching test-writing this way will tend to harden those parts of your software that are the most basic (and thus the most widely-used). Sake requires a lot of &lt;span class="caps"&gt;URL&lt;/span&gt;-generation, so it made sense to start with the &lt;code&gt;url_rewriter&lt;/code&gt; for test coverage. I covered the most basic use-cases: making sure that protocols, subdomains, ports, and query strings were properly handled within the application (regardless of the presence of mod_rewrite). Great!&lt;/p&gt;
&lt;p&gt;&amp;#8220;Now what?&amp;#8221; This is the question you should be asking every time you created a passing unit test. Is my next-simplest test in this case test case, or should I start a new test case to make sure that my controllers are being loaded properly? There is more marginal value in the short term for adding a test against a widely-used feature than making sure a 4-d array in the query string will map properly into your framework. If the controllers aren&amp;#8217;t being loaded, your query string isn&amp;#8217;t going to mean much, anyway! Your first test of controllers means more than your 20th test of &lt;span class="caps"&gt;URL&lt;/span&gt; rewriting in the short term. Of course, none of this is particularly contentious.&lt;/p&gt;
&lt;p&gt;What about a situation where a unit test you&amp;#8217;ve written doesn&amp;#8217;t pass? At this point, we need to consider whether we&amp;#8217;re in a position to change framework code. What hat are we wearing? If we&amp;#8217;re wearing our unit testing hat and we&amp;#8217;re working against an existing codebase, we might favor altering the tests to get them to pass, rather than altering the framework to implement appropriate functionality. Cross this line too many times and you may end up in a situation where you&amp;#8217;re crossing into untested territory. Fixing concepts in one area of the framework quickly leads to other parts, and we&amp;#8217;re right back to where we were. Even though it will make the developer within you cringe, set aside the test for now&amp;#8212;or simplify it to make it pass&amp;#8212;and simultaneously write up the bug. You are using issue-tracking, aren&amp;#8217;t you?!&lt;/p&gt;
&lt;p&gt;What now? Say you&amp;#8217;ve got your basic functionality covered well. Your software works as it did&amp;#8212;you haven&amp;#8217;t changed anything, except for the tests themselves, so there should be no possible way to introduce a regression. When is it time to make the transition from post-hoc test coverage to test-driven development? This is a slightly less well-defined subject area. Sometimes writing tests for existing functionality will lead to ideas for new functionality within existing units. To be sufficiently vague, it&amp;#8217;s time to start revisiting all of those QA defects you wrote up in the previous section and making the quality changes to your framework. You need to be confident enough in your test coverage to know that you aren&amp;#8217;t adding blatant regressions to your code. You probably don&amp;#8217;t need 100% coverage (which is a myth, anyway), but you also don&amp;#8217;t want to rely on your build to tell you whether everything&amp;#8217;s ok. This is less of &amp;#8220;test-driven development&amp;#8221; and more of &amp;#8220;test-driven test coverage improvements.&amp;#8221; We&amp;#8217;re going back through our code and adding coverage that really ought to have been there in the first place. In order to add this coverage, we might need to step in and clean up a few messes.&lt;/p&gt;</content>
    <summary type="html">Sometimes we revisit old projects that don't include unit tests. Sometimes we neglect to write unit tests during development. In situations like these, what is the best approach to then going back and adding the "necessary" test coverage?</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-03-15:/articles/decorating-php-classes-without-common-ancestor/</id>
    <title type="html">Decorating PHP classes without a common ancestor</title>
    <published>2011-03-15T06:00:00Z</published>
    <updated>2011-03-15T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/decorating-php-classes-without-common-ancestor/"/>
    <content type="html">&lt;p&gt;To change the functionality of the component, the decorator redefines one or more methods; within these methods, some piece of functionality is added or modified, and the result is passed back through to the decorated class. All other method calls are automatically passed through to the component class.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/articles/decorator-abstract.png" title="Abstract decorator pattern, shown with common ancestor" alt="Abstract decorator pattern, shown with common ancestor" /&gt;&lt;/p&gt;
&lt;p&gt;This is all very neat and useful, but I&amp;#8217;ve found myself in situations before where it doesn&amp;#8217;t make sense to include the decorator in the same inheritance hierarchy as the decorated class. For example, I may want my decorator class to inherit from some other class. In &lt;span class="caps"&gt;PHP&lt;/span&gt;, this limitation can be overcome through use of the built-in &lt;a href="http://www.php.net/call_user_func_array"&gt;call_user_func_array&lt;/a&gt; function in conjunction with the &lt;a href="http://php.net/manual/en/language.oop5.overloading.php"&gt;__call&lt;/a&gt; magic method.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/articles/decorator-no-common-ancestor.png" title="Decorator with no common ancestor" alt="Decorator with no common ancestor" /&gt;&lt;/p&gt;
&lt;p&gt;Take the Textile markup library, for example. It&amp;#8217;s an extremely useful piece of software. However, it&amp;#8217;s all wrapped up into a single class. It effectively operates as a single unit. All of its methods are public, so in principle we could simply inherit from Textile and overwrite where appropriate. However, this would require us to continue subclassing for every single decoration that we want to apply. Decorating is a bit more agnostic to the class hierarchy; we can add any decorators we want to specific instances of the class and leave other decorators off.&lt;/p&gt;
&lt;p&gt;In &lt;a href="http://www.github.com/gavinchi/sextile"&gt;sextile&lt;/a&gt;, for example, I decorate the Textile markup class in order to add LaTeX compatibility at runtime. Originally, I went into the Textile 2.0 class itself and hard-coded my own rule. This worked great, until Textile 2.2 was released. In order to use the new features, I would have had to delve into the new code and find out how to add my exception in again. By moving the LaTeX-handling code out into a decorator, I&amp;#8217;m now able to drop different versions of Textile in without worrying about it&amp;#8212;at least provided that the markup mechanism for images hasn&amp;#8217;t changed  between releases.&lt;/p&gt;
&lt;script src="https://gist.github.com/1009388.js"&gt; &lt;/script&gt;&lt;p&gt;Of course, the alternative to this would be a situation where &lt;code&gt;sextile&lt;/code&gt; simply inherits from &lt;code&gt;Textile&lt;/code&gt;. In this case, the &lt;code&gt;TextileThis&lt;/code&gt; method would simply be written as a call to &lt;code&gt;parent::TextileThis(...)&lt;/code&gt; with the wrapper applied to the first parameter. If I wanted to add an additional decorator which modifies hyperlinks (which, in some cases, I do), I would have to subclass this class in a similar manner. Such behavior wouldn&amp;#8217;t be unheard of in, for example, a wiki environment where mathematical markup is needed, and all relative links should go to a predefined location. Decorating, instead of subclassing, allows me to plug in either of these bits of functionality as needed, independently of one another.&lt;/p&gt;
&lt;p&gt;So what is this business about not having a common ancestor? Well, one caveat of the decorator pattern is that the decorator and the concrete class both implement the same abstract class or interface. In the example above, there were two options: create a &lt;code&gt;Textile&lt;/code&gt; subclass to serve as the common parent class for all possible decorators. This is one option, and would be tantamount to introducing a common ancestor into the inheritance hierarchy. However, it would also an extra class to the hierarchy. In the name of parsimony, we can use the flexibility of &lt;span class="caps"&gt;PHP&lt;/span&gt; to achieve the same effect while only adding a single class.&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://www.php.net/call_user_func_array"&gt;call_user_func_array&lt;/a&gt; function accepts two parameters: a callback function (in the case of a function, this is simply a string; in the case of a method, this requires an array containing the instance of the class and the name of the method) and an array of parameters to pass to that function. This means that we can call any method at runtime, provided that we have its name or an instance of its containing class. In conjunction with the &lt;code&gt;__call&lt;/code&gt; magic method available to classes in PHP5, we can intercept method calls to an object and redirect them anywhere we please. That means that, although &lt;code&gt;sextile&lt;/code&gt; and &lt;code&gt;Textile&lt;/code&gt; have different class signatures, they can serve the same purpose in any situation. This helps us with decorators because it allows us to pass non-decorated method calls through to the concrete instance of the decorated class. In a situation where one is interested in decorating &lt;em&gt;all&lt;/em&gt; methods of a class with a common functionality change, this would be a huge benefit. For example, adding logging at runtime.&lt;/p&gt;
&lt;p&gt;One thing to remember about using &lt;code&gt;__call&lt;/code&gt; in combination with &lt;code&gt;call_user_func_array&lt;/code&gt; would be that type hints and calls to the &lt;code&gt;instanceof&lt;/code&gt; operator will fail when comparing instances of class &lt;code&gt;Textile&lt;/code&gt; to instances of class &lt;code&gt;sextile&lt;/code&gt;. This is an unintended negative consequence of forgoing a common ancestor.&lt;/p&gt;
&lt;p&gt;Note that by forgoing a common parent for the decorator classes, we are forced to add this &lt;code&gt;__call&lt;/code&gt; method to every single decorator. This would constitute a pretty clear violation of the &lt;a href="http://c2.com/cgi/wiki?DontRepeatYourself"&gt;&lt;span class="caps"&gt;DRY&lt;/span&gt;&lt;/a&gt; principle, because the same code would exist in multiple classes. I would argue for using your marginal instinct in this case; if you have a handful of decorators, the benefits of duplication might outweigh the costs of maintaining another class. In the case of many possible decorators, the &lt;a href="http://c2.com/xp/CodeSmell.html"&gt;smelly code&lt;/a&gt; might merit a refactoring to a higher place in the hierarchy. Personally I think my balance point would be around 2-3 decorators.&lt;/p&gt;</content>
    <summary type="html">The decorator--or wrapper--pattern is most often used to extend the functionality of the public interface of a specific instance of a class at runtime (rather than at definition-time). Because the behavior is changed at runtime, it allows the functionality of objects instantiated from classes in other libraries, even ones to whose source you may not have access, to be modified. Most commonly, the decorator pattern is described as a pair of classes--a component and a decorator--which derive from a common ancestor.</summary>
  </entry>
</feed>

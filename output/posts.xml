<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://www.zuttonet.com/</id>
  <title>The Dump</title>
  <updated>2011-08-08T06:00:00Z</updated>
  <link rel="alternate" href="http://www.zuttonet.com/"/>
  <link rel="self" href="http://www.zuttonet.com/posts.xml"/>
  <author>
    <name>Ryan</name>
    <uri>http://www.zuttonet.com</uri>
  </author>
  <entry>
    <id>tag:www.zuttonet.com,2011-08-08:/articles/anonymous-recursion-php/</id>
    <title type="html">Anonymous recursion in PHP</title>
    <published>2011-08-08T06:00:00Z</published>
    <updated>2011-08-08T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/anonymous-recursion-php/"/>
    <content type="html">&lt;h2&gt;The scenario&lt;/h2&gt;
&lt;p&gt;You&amp;#8217;re neck deep in 3-year old production code, amazon one-click checkout isn&amp;#8217;t working, and your wife just left you for someone who &amp;#8220;doesn&amp;#8217;t spend so much time writing unit tests.&amp;#8221; You need to save the world by implementing an algorithm using an anonymous function &lt;em&gt;now&lt;/em&gt;. Wait, what if the problem you need to solve is well served with a recursive approach? Maybe you attack the problem optimistically, starting with something like this:&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=super-naive-approach.php"&gt;&lt;/script&gt;&lt;p&gt;&amp;#8220;Well, crap,&amp;#8221; you say, seeing the &lt;code&gt;Fatal error&lt;/code&gt; reported by &lt;span class="caps"&gt;PHP&lt;/span&gt;. Turns out that variables called as functions must be an instance of &lt;code&gt;Closure&lt;/code&gt;, an instance of a class which implements &lt;code&gt;__invoke()&lt;/code&gt;, or a string representing a named function in the global namespace. In the anonymous function body above, &lt;code&gt;$fibonacci&lt;/code&gt; is none of these. It is an undeclared, free variable in the closure created by the anonymous function. At the time when it&amp;#8217;s called, it hasn&amp;#8217;t been bound&amp;#8212;hence the &lt;code&gt;Notice&lt;/code&gt; that you would have gotten if error reporting were set at a high enough threshold&amp;#8212;and therefore can&amp;#8217;t be called as &lt;em&gt;anything&lt;/em&gt;, let alone as a function.&lt;/p&gt;
&lt;p&gt;So how should you proceed? The classical solution would be simply to name this function; instead of binding the function to a variable called &lt;code&gt;$fibonacci&lt;/code&gt;, we should just &lt;em&gt;name&lt;/em&gt; the function &lt;code&gt;fibonacci&lt;/code&gt;. That would certainly be convenient. But what if we encounter a higher-order function that expects a function as a parameter? It happens that many higher-order functions in &lt;span class="caps"&gt;PHP&lt;/span&gt; can simply accept as callbacks the names of functions, but I prefer not to rely on that. In fact, any userland function you write which expects a lambda will work just as happily being sent a string. But what if we &lt;strong&gt;must&lt;/strong&gt; provide the higher-order function with the means of calculating the nth Fibonacci number? How could we even go about implementing the recursion required to pull it off? I&amp;#8217;m so glad you asked.&lt;/p&gt;
&lt;h2&gt;Naming the nameless&lt;/h2&gt;
&lt;p&gt;The difficult part about the above is that we have no good way to actually call the function in whose body we are executing while we&amp;#8217;re still in it. The thing&amp;#8217;s anonymous, after all&amp;#8212;we are essentially looking for some way to break its anonymity, to call the nameless by name. Well, we may not be able to actually extract the name of this function for the purpose of calling it again, but we do have some information about the location where it&amp;#8217;s held in memory. This location is known to &lt;code&gt;$fibonacci&lt;/code&gt;, the value we&amp;#8217;re using in the parent scope to hold the function itself. Therefore, if we could grab the value of &lt;code&gt;$fibonacci&lt;/code&gt;, we could actually use it to recurse. The problem here is that &lt;code&gt;$fibonacci&lt;/code&gt; does not exist in the scope where we need to use it.&lt;/p&gt;
&lt;p&gt;If you had read my &lt;a href="http://zuttonet.com/articles/anonymous-functions-and-closure-php/"&gt;article about closures&lt;/a&gt;, you would know that we have the ability in &lt;span class="caps"&gt;PHP&lt;/span&gt; to do something that sounds very much like this. With PHP&amp;#8217;s &lt;code&gt;use&lt;/code&gt; keyword for anonymous function definition, we can pull either a value or a reference into a function&amp;#8217;s scope. Let&amp;#8217;s be naive and pull in the &lt;em&gt;value&lt;/em&gt; of &lt;code&gt;$fibonacci&lt;/code&gt; in a forshadowingly misguided attempt to recurse:&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=naive-closure-approach.php"&gt;&lt;/script&gt;&lt;p&gt;This new function actually has the exact same body as our original attempt; the only difference is that we are now pulling in the value of &lt;code&gt;$fibonacci&lt;/code&gt; from the parent scope and binding it at definition-time. Running this, we actually get the exact same error we got above. Why?&lt;/p&gt;
&lt;p&gt;Without going into the nitty gritty details, let&amp;#8217;s walk through what&amp;#8217;s happening here. First, we declare a variable called &lt;code&gt;$fibonacci&lt;/code&gt; and then assign to it the anonymous function. Here&amp;#8217;s the problem: this function statement doesn&amp;#8217;t terminate until &lt;em&gt;after&lt;/em&gt; the value of &lt;code&gt;$fibonacci&lt;/code&gt; is pulled into its body and used. Since we are @use@ing &lt;code&gt;$fibonacci&lt;/code&gt; by value, that value is declared but undefined when we actually pull it into the function scope. Notice that there is no fatal error here &lt;em&gt;until&lt;/em&gt; we actually execute &lt;code&gt;$fibonacci()&lt;/code&gt;. That&amp;#8217;s very important.&lt;/p&gt;
&lt;h2&gt;Closure-by-reference&lt;/h2&gt;
&lt;p&gt;Seeing that this doesn&amp;#8217;t work, let&amp;#8217;s take a slightly different approach by bringing &lt;code&gt;$fibonacci&lt;/code&gt; into the anonymous function by reference (in functional parlance, let&amp;#8217;s close our anonymous function over &lt;code&gt;$fibonacci&lt;/code&gt;). By doing so, we still pull &lt;code&gt;$fibonacci&lt;/code&gt; into our function before it actually refers to anything useful. However, because we are closing by reference, rather than by value, &lt;code&gt;$fibonacci&lt;/code&gt; will be properly defined by the time we actually need to run it. Remember how we didn&amp;#8217;t get the error by value until we executed the function? That problem goes away now, because by the time we execute the function, the variable holding it for us is &lt;em&gt;actually&lt;/em&gt; holding it for us.&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=closure-by-reference.php"&gt;&lt;/script&gt;&lt;p&gt;Now that we have a working recursive anonymous function, let&amp;#8217;s explore some examples of what we can do with it. One nice thing about this particular implementation (which emphatically isn&amp;#8217;t due to its anonymous nature, but rather by design) is that it is completely non-destructive.&lt;/p&gt;
&lt;h2&gt;Applications&lt;/h2&gt;
&lt;p&gt;Here are some applications of what we&amp;#8217;ve accomplished above:&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;map&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;Functional programming in &lt;span class="caps"&gt;PHP&lt;/span&gt; is a whole &amp;#8216;nother level of ugly. Here&amp;#8217;s an implementation of &lt;code&gt;map&lt;/code&gt;, a higher-order function which takes a single-argument function and applies it to each element in a collection. Here, we pass it &lt;code&gt;$fibonacci&lt;/code&gt;, which holds our recursive anonymous function.&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=php-library-map.php"&gt;&lt;/script&gt;&lt;h3&gt;&lt;code&gt;reduce&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt; is another common higher-order function. It takes a function of two arguments and a collection and maps the array pairwise into a single value using the function.&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=php-library-reduce.php"&gt;&lt;/script&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If we were in a situation where we needed to make use of a higher-order function like one of these above, it would be very inconvenient to be limited to only using anonymous functions which could not be written recursively. With these &amp;#8220;pass-by-reference closures&amp;#8221; in &lt;span class="caps"&gt;PHP&lt;/span&gt;, we can circumvent that limitation and provide our anonymous function to any higher-order function that can use it.&lt;/p&gt;
&lt;p&gt;This is still a somewhat poor solution, however, because our functions are no longer truly anonymous. Instead of binding the name of the function to an identifier, we are binding the name of our function to a variable. In case we wanted to change the name of the function, or provide recursion like this in an inner-anonymous function, we might struggle.&lt;/p&gt;</content>
    <summary type="html">I've been working toward building a useful set of concepts to apply some functional programming techniques in PHP 5.3. Yes, _functional_ programming in PHP. In this article, I explore the concept of anonymous recursion, something that becomes important in situations where we are using anonymous functions to solve problems that are well suited to a recursive approach.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-07-15:/articles/anonymous-functions-and-closure-php/</id>
    <title type="html">Anonymous functions and closure in PHP</title>
    <published>2011-07-15T06:00:00Z</published>
    <updated>2011-07-15T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/anonymous-functions-and-closure-php/"/>
    <content type="html">&lt;p&gt;&lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3 introduced function literals to the language, providing big benefits in the form of syntax and readability when using and creating functions that accept other functions as arguments. However, the introduction of &lt;a href="http://php.net/manual/en/functions.anonymous.php"&gt;anonymous functions&lt;/a&gt; was paired with another useful language construct which allows us to close over local variables in the same scope as the anonymous function, creating a closure.&lt;/p&gt;
&lt;h2&gt;What is closure?&lt;/h2&gt;
&lt;p&gt;According to Wikipedia, a &lt;strong&gt;closure&lt;/strong&gt; is a&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;function together with a referencing environment for the nonlocal names (free variables) of that function&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A closure is so-called because it is &lt;em&gt;closed over&lt;/em&gt; its free variables. These free variables, or &lt;em&gt;upvalues&lt;/em&gt;, come from the enclosing scope of the anonymous function and persist even after that scope, and all references to it, is otherwise made unavailable (e.g., by the function execution completing and returning control back to the previous frame).&lt;/p&gt;
&lt;p&gt;What does this mean for you, as a &lt;span class="caps"&gt;PHP&lt;/span&gt; developer? If you&amp;#8217;re only using vanilla functions to read in and act upon or modify global variables, then probably not much. You can already do something functionally &lt;em&gt;similar&lt;/em&gt; (emphasis) to this using the much-maligned &lt;a href="http://us.php.net/manual/en/language.variables.scope.php#language.variables.scope.global"&gt;&lt;code&gt;global&lt;/code&gt; keyword&lt;/a&gt; to import variable references from the global scope. However, when working somewhere other than the global scope&amp;#8212;or when using anonymous functions&amp;#8212;closures are a powerfully expressive means for performing many otherwise tedious and complicated tasks.&lt;/p&gt;
&lt;h2&gt;What isn&amp;#8217;t closure?&lt;/h2&gt;
&lt;p&gt;First, let&amp;#8217;s walk through an example of using the &lt;code&gt;global&lt;/code&gt; keyword in a function defined in the global namespace as a basis for comparison against the closures we&amp;#8217;ll talk about momentarily.&lt;/p&gt;
&lt;h3&gt;The &lt;code&gt;global&lt;/code&gt; keyword&lt;/h3&gt;
&lt;p&gt;Suppose you are writing a function that, for some &lt;em&gt;good&lt;/em&gt; reason, requires you to change a variable defined outside of the function&amp;#8217;s scope. We can import the variable from the global scope into the function scope using the &lt;code&gt;global&lt;/code&gt; keyword, like so:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=basic-global.php"&gt;&lt;/script&gt;&lt;p&gt;The output of this script would be &lt;code&gt;1&lt;/code&gt;. The &lt;code&gt;global&lt;/code&gt; keyword imports a reference to the global variable &lt;code&gt;$count&lt;/code&gt;, whose value at that time is &lt;code&gt;0&lt;/code&gt;, into the function scope. The global variable itself is then incremented. Because we have imported and incremented a reference, this function actually modifies something in the global namespace.&lt;/p&gt;
&lt;p&gt;A naive reading of the definition of &lt;em&gt;closure&lt;/em&gt; above might lead one to think that this fits the bill. However, the implementation details are slightly different; &lt;span class="caps"&gt;PHP&lt;/span&gt; has a &lt;a href="http://us.php.net/manual/en/language.variables.superglobals.php"&gt;superglobal&lt;/a&gt; variable named &lt;code&gt;$GLOBALS&lt;/code&gt; that is accessible from within any scope. The &lt;code&gt;global $var&lt;/code&gt; construct is simply syntactic sugar for the much uglier &lt;code&gt;$var = &amp;amp;$GLOBALS['var'];&lt;/code&gt; expression, which would have the same effect. Because this is simply a reference to a superglobal, we could in principle observe manipulation of this variable from another source, outside of the function. This is not closure.&lt;/p&gt;
&lt;h3&gt;Scope within a scope&lt;/h3&gt;
&lt;p&gt;Another reason this does not create closure is due to the fact that, no matter within which scope you currently operate, &lt;code&gt;global&lt;/code&gt; imports only references from the &lt;em&gt;global&lt;/em&gt; namespace (due to the implementation reality outlined above). For example, a function within a function cannot import scope from its parent using &lt;code&gt;global&lt;/code&gt;, but only from the global namespace.&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=global-inner-function.php"&gt;&lt;/script&gt;&lt;p&gt;Running the program above will output &lt;code&gt;1 1&lt;/code&gt; (no spaces). This shows that &lt;code&gt;global&lt;/code&gt; imports variables only from the global namespace, not just from the &amp;#8220;parent&amp;#8221; namespace. Closure would require either the &lt;code&gt;global&lt;/code&gt; statement to grab from the next-highest namespace, or simply allow the parent scope to creep into the child scope (another style of scoping entirely, a la javascript). This is not closure.&lt;/p&gt;
&lt;h3&gt;Anonymous functions&lt;/h3&gt;
&lt;p&gt;Is an anonymous function a closure, then? Anonymous functions and closures are often conflated, but they are distinct concepts. I think the garden path I&amp;#8217;ve been leading you on so far should have steered you away from this, but let&amp;#8217;s just make sure. We know that simply using &lt;code&gt;global&lt;/code&gt; isn&amp;#8217;t closure because of its implementation-that it doesn&amp;#8217;t actually close over variables within the function-defining scope, it just brings them into the current scope by reference. Anonymous functions are still functions, and &lt;code&gt;global&lt;/code&gt; operates within them the same way it operates within named functions. Anonymous functions are not closures.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m unclear on the low-level implementation details of functions versus anonymous functions in &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3, but there is no practical difference in terms of the ostensible constraints they face in terms of scope, input, and output. For example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=function-literal-global.php"&gt;&lt;/script&gt;&lt;p&gt;The only meaningful difference here is that &lt;code&gt;increase_count&lt;/code&gt; is given a name at define-time, while &lt;code&gt;$increase_count_again&lt;/code&gt; is assigned a function literal which is executed by variable name at run time. They both face the same rules &lt;em&gt;vis-a-vis&lt;/em&gt; &lt;code&gt;global&lt;/code&gt;, and the fact that this script outputs &lt;code&gt;2&lt;/code&gt; is proof of that.&lt;/p&gt;
&lt;h2&gt;The &lt;code&gt;use&lt;/code&gt; keyword&lt;/h2&gt;
&lt;p&gt;So what is closure? You&amp;#8217;ve been reading long enough now that you might suspect I&amp;#8217;ve eliminated every possible misconception and misunderstanding that could possible arise. That&amp;#8217;s not true; closure is a difficult concept to grasp, and misunderstanding it can lead to misuse, which can introduce hard-to-detect bugs.&lt;/p&gt;
&lt;p&gt;Closure requires both a function, with its own scope, and a surrounding environment which persists through an arbitrary number of executions of that function. So, an anonymous function is insufficient. In order to produce a closure, we need to be able to create the surrounding environment. Luckily, &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3 also introduced a very useful construct for turning anonymous functions into closures.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;use&lt;/code&gt; by value&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;use&lt;/code&gt; keyword, when paired with a function literal&amp;#8212;or anonymous function&amp;#8212;allows us to import variable values or references into the scope of the function. Here&amp;#8217;s an example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=simple-naive-closure-value.php"&gt;&lt;/script&gt;&lt;p&gt;We use &lt;code&gt;$count&lt;/code&gt; by value, so the output of the script is &lt;code&gt;1&lt;/code&gt;. This is because &lt;span class="caps"&gt;PHP&lt;/span&gt; binds a function-local variable named &lt;code&gt;$count&lt;/code&gt; to the value of the parent-local &lt;code&gt;$count&lt;/code&gt; at the time the function literal is defined. Even if we change the value of the parent-local &lt;code&gt;$count&lt;/code&gt; (say, by incrementing it between defining &lt;code&gt;$decrease_count&lt;/code&gt; and calling it), its value within the function body will not change. This also implies that changing &lt;code&gt;$count&lt;/code&gt; in the function-local scope will have no effect on the value of &lt;code&gt;$count&lt;/code&gt; in the parent-local scope. This is not closure.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;use&lt;/code&gt; by reference&lt;/h3&gt;
&lt;script src="https://gist.github.com/1084089.js?file=simple-naive-closure-reference.php"&gt;&lt;/script&gt;&lt;p&gt;I keep using the phrase &amp;#8220;by value or reference&amp;#8221; because either is possible. Notice in the example above that I have prefixed &lt;code&gt;$count&lt;/code&gt; with &lt;code&gt;&amp;amp;&lt;/code&gt;, the &lt;span class="caps"&gt;PHP&lt;/span&gt; symbol that makes an assignment &lt;a href="http://php.net/manual/en/language.references.pass.php"&gt;by reference&lt;/a&gt;. The output of the above script is as expected: &lt;code&gt;$count&lt;/code&gt; from the parent-local scope is decremented in the function-local scope and the printed result is &lt;code&gt;0&lt;/code&gt;. Notice especially that this particular script need not be defined in the global namespace (the file in which it&amp;#8217;s defined could be included in a function, for example); &lt;code&gt;use&lt;/code&gt; always refers to the scope in which the function is defined. This is closure.&lt;/p&gt;
&lt;p&gt;More basically, you might ask: how is this any different from using &lt;code&gt;global&lt;/code&gt; inside a function defined in the global namespace? The most important way is that it allows us to import a value or reference from the immediate-parent scope, not just the global scope. The tuple following the &lt;code&gt;use&lt;/code&gt; keyword tells &lt;span class="caps"&gt;PHP&lt;/span&gt; to import values or references to each element into the function scope.&lt;/p&gt;
&lt;p&gt;Ok, so you can import variables by reference into anonymous functions. What&amp;#8217;s the big deal? Well, now that you understand many of the things that &lt;em&gt;aren&amp;#8217;t&lt;/em&gt; closure (and have an example of something that technically &lt;em&gt;is&lt;/em&gt; closure), let&amp;#8217;s see what you can do with it.&lt;/p&gt;
&lt;h2&gt;Usage of closure&lt;/h2&gt;
&lt;p&gt;Under usual circumstances and in many languages, any variable allocated within a function body is lost when that function&amp;#8217;s execution is completed, because the frame containing it is popped (although this &lt;a href="http://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope"&gt;isn&amp;#8217;t exactly right in all languages&lt;/a&gt;). Within a closure, however, we can maintain and manipulate the information created inside of an enclosing function even after that enclosing function has finished execution. Check out the following example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=full-closure-count.php"&gt;&lt;/script&gt;&lt;p&gt;In this script, the body of the &lt;code&gt;create_closure&lt;/code&gt; function has a local variable named &lt;code&gt;$count&lt;/code&gt;. &lt;code&gt;create_closure&lt;/code&gt; returns an anonymous function which has by-reference access to this local variable. Therefore, where references to @create_closure@&amp;#8217;s &lt;code&gt;$count&lt;/code&gt; would typically lose all meaning when its body was finished executing, there now remains a reference to it &lt;em&gt;within&lt;/em&gt; any variable to which the anonymous function is assigned. &lt;strong&gt;&lt;code&gt;create_closure&lt;/code&gt; creates a closure because it returns a function together with a referencing environment for the nonlocal names of that function&lt;/strong&gt;. This is closure.&lt;/p&gt;
&lt;p&gt;Notice the output of the above (shown inline as comments). We call the anonymous function three times, and the output changes each time, even though the body of the anonymous function really does nothing interesting. &lt;code&gt;$closure&lt;/code&gt; has &amp;#8220;closed over&amp;#8221; &lt;code&gt;$count&lt;/code&gt; and now has local access to it for any call to &lt;code&gt;$closure()&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;More advanced usage&lt;/h2&gt;
&lt;p&gt;What if we generate multiple closures; how is this handled? I&amp;#8217;m so glad you asked.&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=full-closure-count-2.php"&gt;&lt;/script&gt;&lt;p&gt;We now create two different closures. You noticed, of course, that the function generating the closures is parameterized by &lt;code&gt;$count&lt;/code&gt;. Since we call this function twice&amp;#8212;each time with a different parameter value&amp;#8212;it shouldn&amp;#8217;t come as a surprise that we will receive two separate closures, each closed over a different value for &lt;code&gt;$count&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Anonymous functions and closures are a very neat and powerful addition to &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3. I hope after reading this article you better understand how to use these new language features, and maybe even have a better idea of why they&amp;#8217;re a big improvement over what was previously available. This article is meant to serve as a basic introduction and overview of the language-level characteristics of closures. Let me know what you think!&lt;/p&gt;</content>
    <summary type="html">PHP 5.3 introduced function literals to the language, providing big benefits in the form of syntax and readability when using and creating functions that accept other functions as arguments. However, the introduction of anonymous functions was paired with another useful language construct which allows us to close over local variables in the same scope as the anonymous function, creating a closure.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-06-13:/articles/dead-simple-profiling-in-php/</id>
    <title type="html">Simple performance profiling in PHP 5.3</title>
    <published>2011-06-13T06:00:00Z</published>
    <updated>2011-06-13T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/dead-simple-profiling-in-php/"/>
    <content type="html">&lt;p&gt;I love finding new ways to use PHP&amp;#8217;s anonymous functions. One thing that caught my attention recently is how they make it so easy to wrap scope and functionality into little packages. These packages can easily be fed to a utility function, allowing the functionality contained therein to be wrapped and modified dynamically.&lt;/p&gt;
&lt;p&gt;How nice would it be if there were a simple way to wrap up some script execution and figure out how long it takes? Or to take multiple versions of a function&amp;#8212;or class, or whatever&amp;#8212;and figure out which one runs in less time? It would be super nice. Unfortunately, I have never really run across a very &lt;em&gt;simple&lt;/em&gt; way to do that. So I wrote a function, called &lt;code&gt;profile&lt;/code&gt;, which accepts a diagnostic messge and a lambda which wrap around the code you are interested in profiling.&lt;/p&gt;
&lt;p&gt;The lambda that &lt;code&gt;profile&lt;/code&gt; takes should just be an anonymous function that contains all of the code that you&amp;#8217;re interested in profiling. It could also be a named function, or even an object that implements &lt;code&gt;__invoke&lt;/code&gt; (a functor). Just make sure that the thing you&amp;#8217;re passing as a callback contains the code you want to time.&lt;/p&gt;
&lt;script src="https://gist.github.com/1025970.js?file=profile.php"&gt;&lt;/script&gt;&lt;p&gt;All this function does is record the current time in microseconds, execute the function you passed, check the time again, and then return a string representation of the execution time. Simple enough, right!? I had a hard time finding something anywhere else that was so simple, though. Here&amp;#8217;s an example of it in action:&lt;/p&gt;
&lt;script src="https://gist.github.com/1025970.js?file=simple_test.php"&gt;&lt;/script&gt;&lt;p&gt;The world of performance profiling and optimization is now your oyster. Of course, this approach is limited by the implementation details of anonymous functions. For example: if you want to globalize variables from a broader scope to use in your callback, you&amp;#8217;ll have to import them using the &lt;code&gt;use&lt;/code&gt; keyword in the definition, creating a closure.&lt;/p&gt;
&lt;p&gt;The simple &lt;code&gt;profile&lt;/code&gt; function could be broadened a bit by wrapping the profile function up into a profiling class that would save information about various executions&amp;#8212;maybe even duplicating them and providing statistical information about those runs. The function also makes pretty bold assumptions about how information about the execution time should be packaged; this could certainly use some abstraction. Sounds like a good evening project!&lt;/p&gt;</content>
    <summary type="html">PHP's standard library makes it pretty easy to whip up a quick set of timing functions to wrap around your code. Maybe I'm jaded by ruby's blocks, but I would love to see that my profiling code is getting everything I want and _only_ those things I want. So I decided to sit down and whip up something quick and simple to alleviate my neurosis.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-06-07:/articles/setting-up-a-nanoc-website/</id>
    <title type="html">nanoc websites with binary data</title>
    <published>2011-06-07T06:00:00Z</published>
    <updated>2011-06-07T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/setting-up-a-nanoc-website/"/>
    <content type="html">&lt;p&gt;Nanoc is fantastic. I would definitely recommend it to anyone. However, any time I approach something new on a computer, there&amp;#8217;s always a struggle between the information available in the documentation (typically written by the developer, who already knows what&amp;#8217;s up) and the information I really need to know to use the software.&lt;/p&gt;
&lt;h2&gt;Minor frustrations&lt;/h2&gt;
&lt;p&gt;The first thing that tripped me up about nanoc was how best to handle my images and other binary files. I think the documentation talks about binary files a bit, but I was left a little confused even after several reads through. I knew that the standard nanoc metadata couldn&amp;#8217;t simply be added to the top of the file, but I had trouble figuring out how to get the files where I wanted them to go. A little trial and error helped, but the biggest breakthrough came after I worked with the process as a whole. What follows here is an example of my compilation and routing rules for my basic images and the rest of the files on my site.&lt;/p&gt;
&lt;h2&gt;Compilation and routing&lt;/h2&gt;
&lt;p&gt;Basically, nanoc consists of two steps: compilation and routing.&lt;/p&gt;
&lt;h3&gt;Compilation&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Compilation&lt;/strong&gt;, the way I see it, is the process of taking particular items (this is actually how they&amp;#8217;re called in nanoc parlance) and transforming their contents according to specific rules. These rules are created by you. To help you, nanoc provides a bunch of built-in helpers (nicely packaged functionality for generating stuff on your site) and filters (formatting rules, etc, through which your pages are run&amp;#8212;e.g. markdown, textile) while exposing a simple api for accessing each item as given. Compilation can be as complicated as translating into another language or as simple as a pass-through. The articles on this site, for example, are simply passed through RedCloth (a Ruby textile implementation) and written.&lt;/p&gt;
&lt;h3&gt;Routing&lt;/h3&gt;
&lt;p&gt;After all of the items are compiled and linked, they&amp;#8217;re routed. &lt;strong&gt;Routing&lt;/strong&gt; is the process of actually putting the compiled files where they need to go. Routing rules match item identifiers (in the same way that compilation rules do) and allow you to return a string different than the identifier itself. Ultimately, the item placed in a subdirectory &lt;code&gt;/output/&lt;/code&gt; according to the string you return in the routing rule matching that file. Routing &lt;code&gt;/foo/&lt;/code&gt; to &lt;code&gt;/pages/foo/&lt;/code&gt; for example, will cause the output file to be placed in &lt;code&gt;pages/foo/index.html&lt;/code&gt; instead of &lt;code&gt;foo/index.html&lt;/code&gt; by default. You could also route &lt;code&gt;/foo/&lt;/code&gt; to &lt;code&gt;/foo.html&lt;/code&gt; if you wanted. The routing rule is given an item object to work with, which includes data about the identifier, the path, the extension, and other things.&lt;/p&gt;
&lt;h2&gt;Examples&lt;/h2&gt;
&lt;p&gt;Here&amp;#8217;s a subset of the compilation and routing rules I use for the index page and the articles for this website:&lt;/p&gt;
&lt;script src="https://gist.github.com/1012755.js?file=compile_and_route_articles.rb"&gt;&lt;/script&gt;&lt;h3&gt;Root pages&lt;/h3&gt;
&lt;p&gt;First first rule catches the html files in the content/ directory, filters them through &lt;code&gt;:erb&lt;/code&gt; (the standard filter you&amp;#8217;d want to apply if you were doing any sort of ruby &lt;span class="caps"&gt;ERB&lt;/span&gt; markup in the page). Since I want to build my index.html to dynamically list the most recent articles using Ruby, this is the appropriate filter. Then I apply the &lt;code&gt;page&lt;/code&gt; layout (which is another erb file located in &lt;code&gt;layouts/&lt;/code&gt;). Once a file has matched a compilation rule, it won&amp;#8217;t be run through any others.&lt;/p&gt;
&lt;h3&gt;Articles&lt;/h3&gt;
&lt;p&gt;Articles follow the same basic guideline, except they&amp;#8217;re filtered through &lt;code&gt;:redcloth&lt;/code&gt; (the textile filter) since they contain no &amp;#8220;dynamic&amp;#8221; content. I say &amp;#8220;dynamic&amp;#8221; because even the &lt;code&gt;:erb&lt;/code&gt; stuff from above becomes static &lt;span class="caps"&gt;HTML&lt;/span&gt; during the compilation process. The &lt;code&gt;article&lt;/code&gt; layout is applied to these files. Both root pages and articles are then simply routed based on their identifiers (so their relative directory structure does not change).&lt;/p&gt;
&lt;h3&gt;Images&lt;/h3&gt;
&lt;p&gt;Now, Back to images: images require no compilation, because (in some sense) they&amp;#8217;re already compiled. In fact, if we want to avoid problems during our file compilation process, we will need to &lt;em&gt;prevent&lt;/em&gt; any sort of compilation from being done to them. The easiest way to do this is to set up an empty rule; a rule block that does nothing. Failure to do this will result in the images being compiled by your default rule; if this default rule does anything that might break on a binary file, the whole compilation process will fail.&lt;/p&gt;
&lt;p&gt;After passing through the compilation process, binary files must be routed to their final destination. In my situation, I wanted to be able to access all of my images with a route (or absolute &lt;span class="caps"&gt;URI&lt;/span&gt;) that resembled &lt;code&gt;"/images/name.ext"&lt;/code&gt;. Easy enough-I set up a rule that routes all files in the &lt;code&gt;/content/images&lt;/code&gt; directory of my nanoc install to &lt;code&gt;/output/images/name.ext&lt;/code&gt; (including any subdirectory names).&lt;/p&gt;
&lt;p&gt;Here are the compilation and routing rules I use for basic images on this website:&lt;/p&gt;
&lt;script src="https://gist.github.com/1012755.js?file=compile_and_route_images.rb"&gt;&lt;/script&gt;&lt;p&gt;Looking at the routing rules, it might seem like nanoc is just wasting time-after all, why would I not just put the files in the output structure that I want to begin with? The real value in the routing defaults, as I see it, is that nanoc prefers to rename files to &lt;code&gt;index.html&lt;/code&gt; and place them in a subdirectory that corresponds to the old filename. This is useful, because instead of having to type a url like: &lt;code&gt;zuttonet.com/pages/contact.html&lt;/code&gt;, you can simply make your request for &lt;code&gt;zuttonet.com/pages/contact&lt;/code&gt; instead (provided that &lt;code&gt;index.html&lt;/code&gt; is set as your web server&amp;#8217;s default file to serve when a directory is requested). Pretty cool!&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;</content>
    <summary type="html">nanoc is a wonderful little gem that uses Ruby/ERB to create statically-generated websites. It saves you the trouble of firing up a database connection on every request while still allowing you the flexibility of Ruby to generate your sites. I wrote a quick walkthrough to bridge the gap between what I learned through the nanoc documentation and what I needed to know to finish converting my own site.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-04-07:/articles/late-game-unit-testing/</id>
    <title type="html">Late-game unit testing</title>
    <published>2011-04-07T06:00:00Z</published>
    <updated>2011-04-07T06:00:00Z</updated>
    <link rel="alternate" href="http://www.zuttonet.com/articles/late-game-unit-testing/"/>
    <content type="html">&lt;p&gt;I&amp;#8217;ve struggled with this issue recently as I go back and add tests to &lt;a href="http://www.github.com/rgantt/sake"&gt;sake&lt;/a&gt;, my pet &lt;span class="caps"&gt;MVC&lt;/span&gt; framework. The framework&amp;#8217;s deployed on enough sites&amp;#8212;albeit smallish ones&amp;#8212;to confirm that the core functionality is working as intended. When I encounter a framework defect during deployment of a sake site, I revisit the repository and update where necessary. I do &amp;#8220;thorough&amp;#8221; functional tests to ensure that I haven&amp;#8217;t introduced any obvious regressions and then continue to hack happily away on the site.&lt;/p&gt;
&lt;p&gt;Of course, there are several problems with this sort of approach. First, even though functional tests don&amp;#8217;t expose any regression errors, this is not really sufficient evidence to conclude that there &lt;em&gt;actually&lt;/em&gt; weren&amp;#8217;t any regressions. I really don&amp;#8217;t know whether my routing and request-reading code response the same way to all meaningful input combinations that they did before. I only know that they &lt;em&gt;probably&lt;/em&gt; respond identically to &lt;em&gt;those input combinations I was already using.&lt;/em&gt; In short, one person running functional tests just doesn&amp;#8217;t stress enough of the system to grab anything but the lowest-hanging fruit.&lt;/p&gt;
&lt;p&gt;The second problem is that such &lt;em&gt;ad hoc&lt;/em&gt; changes can have an unforeseen impact on The Framework&amp;#8482;. Modifying framework code in response to bugs exposed on an implementation of that framework is emphatically the wrong way to do it. Since I am developing the sites and the framework simultaneously, I may&amp;#8212;even with the best of intentions&amp;#8212;apply fixes in a narrow-minded fashion, losing track of the overall design goals of the framework. My incentives are misaligned because of the duality of my role at the time. A healthy suite of unit tests would, in this situation, act as a set of guardrails against such behavior. They would keep me honest. Making naive fixes to get my sites to run properly would trigger unit test failures, forcing me to do things the right way.&lt;/p&gt;
&lt;p&gt;Ultimately, this is not intended to be an article about the merits of unit testing. The question I&amp;#8217;m wrestling with is what unit tests to &lt;em&gt;start&lt;/em&gt; with when you&amp;#8217;re dealing with an already-completed piece of software that you want to harden against regression. This is inherently a short run concept; in the long run, you&amp;#8217;ll either have full test coverage for your current functionality, or you&amp;#8217;ll be left with a dead piece of software and, maybe, revisiting this article! Then again: in the long run, we&amp;#8217;re all dead. Some of us might prefer that to writing exhaustive tests.&lt;/p&gt;
&lt;p&gt;In general, I favor any solution to a problem where the progression tends from highest to lowest value. In unit testing parlance, this suggests that I write tests which cover the simplest, most basic functionality first. Why not? Approaching test-writing this way will tend to harden those parts of your software that are the most basic and thus the most widely-used. Sake requires a lot of &lt;span class="caps"&gt;URL&lt;/span&gt;-generation, so it made sense to start with the &lt;code&gt;url_rewriter&lt;/code&gt; for test coverage. I covered the most basic use-cases: making sure that protocols, subdomains, ports, and query strings were properly handled within the application (regardless of the presence of mod_rewrite). Great!&lt;/p&gt;
&lt;p&gt;&amp;#8220;What next?&amp;#8221; This is the question you should be asking every time you create a passing unit test. Does my next-highest value test fit within the context of this test case, or should I start a new one to make sure that my controllers are being loaded properly? There is more marginal value in the short term for adding a test against a widely-used feature than making sure a 4-d array in the query string will map properly into your framework. If the controllers aren&amp;#8217;t being loaded, your query string isn&amp;#8217;t going to mean much, anyway! Your first test of controllers means more than your 20th test of &lt;span class="caps"&gt;URL&lt;/span&gt; rewriting in the short term.&lt;/p&gt;
&lt;p&gt;What about a situation where a unit test you&amp;#8217;ve written for functionality that you expect to work doesn&amp;#8217;t pass? At this point, we need to consider whether we&amp;#8217;re in a position to change framework code. What hat are we wearing? If we&amp;#8217;re wearing our unit testing hat and we&amp;#8217;re working against an existing codebase, we might favor altering the tests to get them to pass, rather than altering the framework to implement appropriate functionality. For now. Switching hats too frequently can quickly put you in a situation where your unit test &amp;#8220;debt&amp;#8221; is accruing faster than you&amp;#8217;re paying it off. Making changes in one area of the framework quickly leads changes and broken tests in other parts, and we&amp;#8217;re right back to where we were. Even though it will make the developer within you cringe, set aside the test for now&amp;#8212;or simplify it to make it pass&amp;#8212;and simultaneously write up the bug. You are using an issue-tracking system, aren&amp;#8217;t you?!&lt;/p&gt;
&lt;p&gt;What now? You&amp;#8217;ve got your basic, highest-value functionality covered well. Your software works as it did before you started writing tests&amp;#8212;you haven&amp;#8217;t changed anything, except for the tests themselves, so there should be no possible way to introduce a regression. You&amp;#8217;re pretty confident that new features and improvements won&amp;#8217;t break the framework in unintended ways. You need to take the next step, but you&amp;#8217;re just not sure what it is.&lt;/p&gt;
&lt;p&gt;Now it&amp;#8217;s time to start revisiting all of those QA defects you wrote up in the previous section and making the quality changes to your framework. You need to be confident enough in your test coverage to know that you aren&amp;#8217;t adding blatant regressions to your code. You probably don&amp;#8217;t need 100% coverage (which is a myth, anyway), but you also don&amp;#8217;t want to rely on your build to tell you whether everything&amp;#8217;s ok. This is less of &amp;#8220;test-driven development&amp;#8221; and more of &amp;#8220;test-driven test coverage improvements.&amp;#8221; We&amp;#8217;re going back through our code and adding coverage that really ought to have been there in the first place. In order to add this coverage, we might need to step in and clean up a few messes.&lt;/p&gt;</content>
    <summary type="html">Sometimes I need to add features to old projects for which I didn't write unit tests. Sometimes I neglect to write unit tests during development in new projects. Oops. In situations like these, what are some approaches to then going back and adding "necessary" test coverage?</summary>
  </entry>
</feed>

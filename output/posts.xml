<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://www.zuttonet.com/</id>
  <title>Zutto Development Articles</title>
  <updated>2013-05-28T07:00:00Z</updated>
  <link rel="alternate" href="http://www.zuttonet.com/"/>
  <link rel="self" href="http://www.zuttonet.com/posts.xml"/>
  <author>
    <name>Ryan</name>
    <uri>http://www.zuttonet.com</uri>
  </author>
  <entry>
    <id>tag:www.zuttonet.com,2013-05-28:/articles/introduction-to-prefix-trees/</id>
    <title type="html">The prefix tree: an easily-sortable map implementation for string keys</title>
    <published>2013-05-28T07:00:00Z</published>
    <updated>2013-05-28T07:00:00Z</updated>
    <author>
      <name>Ryan</name>
      <uri>http://www.zuttonet.com</uri>
    </author>
    <link rel="alternate" href="http://www.zuttonet.com/articles/introduction-to-prefix-trees/"/>
    <content type="html">&lt;p&gt;One common implementation of the map abstract data type, a hash table, provides fast lookup, insertion, and deletion. Unfortunately, data stored in a hash table makes no guarantee about order. Even binary tree-based implementations, with their natural sorting, are not optimized around sorting stored data. Prefix trees (tries) provide a trade-off between insertion, deletion, and sorting speed by breaking up data into smaller chunks and allowing nodes to have many children. By doing this, they offer a convenient representation of strings that can be easily used in applications like spellcheck and auto-complete.&lt;/p&gt;
&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;A prefix tree&amp;#8212;or, more commonly, trie, for re&lt;em&gt;trie&lt;/em&gt;val&amp;#8212;is a data structure optimized to store values associated with a string key. Tries are useful because they allow fast (&lt;code&gt;O(L)&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; is the length of the word) lookup on string keys, scale easily for large collections of small, short words, and (in many easy implementations) provide built-in lexicographical sorting on traversal.&lt;/p&gt;
&lt;p&gt;Being a &lt;code&gt;Map&lt;/code&gt;, prefix trees support at least the &lt;code&gt;put(K key, V value)&lt;/code&gt;, &lt;code&gt;get(K key)&lt;/code&gt;, and &lt;code&gt;delete(K key)&lt;/code&gt; operations. In addition, it is very simple (and desirable) to also support &lt;code&gt;traverse()&lt;/code&gt;, particularly for an in-order (and therefore lexicographically-ordered) traversal.&lt;/p&gt;
&lt;p&gt;Despite the fact that, in a basic trie, the value of each node will contain only one character, the type &lt;code&gt;K&lt;/code&gt; of the key is typically &lt;code&gt;String&lt;/code&gt;. Implementations worry about how to allocate the component parts of that string across nodes internally. Most simply, they will be allocated letter-by-letter, although some implementations chunk substrings on nodes that have one or fewer children.&lt;/p&gt;
&lt;h2&gt;Internal structure&lt;/h2&gt;
&lt;p&gt;Each node of a prefix tree represents a letter in a word, except for the root node, which contains a pointer to all possible word starts. In other words, each node (including the root), has up to 27 children (one for each letter of the alphabet, plus another for a possible leaf node which contains a value).&lt;/p&gt;
&lt;p&gt;Traversing downward, a word can be constructed by following any path from the root down to a leaf node. Note that even nodes that contain a leaf node as a child may be substrings of other words; the implementations of &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; give meaning to this, not the structure of the trie itself.&lt;/p&gt;
&lt;p&gt;Below is a graphical representation of a trie that contains the following set of words: &lt;code&gt;am&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/articles/tries/simple_trie.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;You can see that since &lt;code&gt;am&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt; share a prefix, we reduce space usage by only having to store the &lt;code&gt;a&lt;/code&gt; one time.&lt;/p&gt;
&lt;h2&gt;Implementation algorithms&lt;/h2&gt;
&lt;p&gt;Prefix trees are just that: trees. For the sake of simplicity, let&amp;#8217;s assume that our trie stores &lt;span class="caps"&gt;ASCII&lt;/span&gt; words. In that case, each node in our tree has 27 children. With 27 children to manage, we need to consider what kind of data structure to use. Using a list would be fine (since list implementations abound), but lookup is slow (and insertion into a sorted list is slow). We could use an array and rely on translating between characters and integers to make the indexing work. Instead, let&amp;#8217;s use a &lt;code&gt;TreeMap&lt;/code&gt;. This will give us quick lookup and insertion on the character keys (&lt;code&gt;O(log n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of children, which is at most 27).&lt;/p&gt;
&lt;script src="https://gist.github.com/rgantt/61c1049eb7b650e32043.js?file=node.java"&gt;&lt;/script&gt;&lt;p&gt;Our prefix tree is composed of &lt;code&gt;Node&lt;/code&gt; objects that contain &lt;code&gt;String&lt;/code&gt; keys and values of type &lt;code&gt;V&lt;/code&gt;, which is a type-parameter of our &lt;code&gt;Trie&lt;/code&gt; class. Now let&amp;#8217;s walk through some simple implementations of the operations we need to support.&lt;/p&gt;
&lt;h3&gt;get&lt;/h3&gt;
&lt;p&gt;Retrieving the value for a given key within a trie (if it exists), is simple:&lt;/p&gt;
&lt;p&gt;1. Grab the first letter of the key; call it &lt;code&gt;k&lt;/code&gt;&lt;br /&gt;
2. Get a pointer to the child of the current node whose key matches &lt;code&gt;k&lt;/code&gt;&lt;br /&gt;
3. If the child is &lt;code&gt;null&lt;/code&gt;, return &lt;code&gt;null&lt;/code&gt;&lt;br /&gt;
4. Else if the key and &lt;code&gt;k&lt;/code&gt; are equal (i.e. the key has length 1), return the child&amp;#8217;s value &lt;code&gt;V&lt;/code&gt;&lt;br /&gt;
5. Else &lt;code&gt;get&lt;/code&gt; the value of the remainder of the key, rooted at the child&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s an implementation of the above algorithm:&lt;/p&gt;
&lt;script src="https://gist.github.com/rgantt/61c1049eb7b650e32043.js?file=get.java"&gt;&lt;/script&gt;&lt;h3&gt;put&lt;/h3&gt;
&lt;p&gt;Trie insertion follows a very similar process to retrieval. Instead of failing early on &lt;code&gt;null&lt;/code&gt; children, though, insertion creates the children required for each letter of the key. Then, when there are no keys left, the final child is assigned a value (turning it into a leaf).&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s the process:&lt;/p&gt;
&lt;p&gt;1. Grab the first letter of the key; call it &lt;code&gt;k&lt;/code&gt;&lt;br /&gt;
2. Get a pointer to the child of the current node whose key matches &lt;code&gt;k&lt;/code&gt;&lt;br /&gt;
3. If the child is &lt;code&gt;null&lt;/code&gt;, create a new &lt;code&gt;Node&lt;/code&gt; with key &lt;code&gt;k&lt;/code&gt; and add it as a child to the current node&lt;br /&gt;
4. If the key and &lt;code&gt;k&lt;/code&gt; are equal (i.e. the key has length 1), assign the child&amp;#8217;s value &lt;code&gt;V&lt;/code&gt;&lt;br /&gt;
4. Else &lt;code&gt;put&lt;/code&gt; the value of the remainder of the key, rooted at the child&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s an implementation of the above algorithm:&lt;/p&gt;
&lt;script src="https://gist.github.com/rgantt/61c1049eb7b650e32043.js?file=put.java"&gt;&lt;/script&gt;&lt;h3&gt;delete&lt;/h3&gt;
&lt;p&gt;Unlike insertion and retrieval, which I&amp;#8217;ve implemented above recursively, I decided to take a slightly different approach for removal. Trie removal has some slightly more subtle edge cases that need to be accounted for. To do so effectively, I opt to traverse the entire key from root to leaf, pushing the nodes onto a stack as I do. Then, by popping elements off the stack, I&amp;#8217;m able to move from the leaf toward the root and handle the edge cases without worrying about recursion.&lt;/p&gt;
&lt;p&gt;The algorithm goes like this:&lt;/p&gt;
&lt;p&gt;1. For a given key, save a list of nodes that represents the path from the root to a leaf&lt;br /&gt;
2. If the path reaches a leaf other than the one representing the key, return null&lt;br /&gt;
3. Start at the leaf. Set its value to null.&lt;br /&gt;
4. While there is path left to traverse and we aren&amp;#8217;t looking at vapid nodes,&lt;br /&gt;
4. a. Remove those nodes from their parent&lt;/p&gt;
&lt;p&gt;By &amp;#8220;vapid&amp;#8221; node in this case, I mean nodes whose values are null and who have no children. These are nodes that should be culled from the trie, otherwise they will contribute unnecessary runtime to subsequent tree traversals, insertions, and deletions.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s an implementation of the above algorithm.&lt;/p&gt;
&lt;script src="https://gist.github.com/rgantt/61c1049eb7b650e32043.js?file=delete.java"&gt;&lt;/script&gt;&lt;p&gt;Note that this implementation relies on a helper, &lt;code&gt;pathFromLeaf(Stack, String)&lt;/code&gt;. I&amp;#8217;ve omitted the implementation of that helper in this example, but you can find it on &lt;a href="https://gist.github.com/rgantt/5711830"&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;traverse&lt;/h3&gt;
&lt;p&gt;Traversal can also be easily implemented recursively. The tricky part about getting the recursion right on traversal is figuring out when a word should be added to the list, and what subkey should pushed into the recursive call.&lt;/p&gt;
&lt;p&gt;We can describe the steps like this:&lt;/p&gt;
&lt;p&gt;1. If the current node has a non-null value, prefix and we should add it to the list&lt;br /&gt;
2. For each of the current node&amp;#8217;s children with non-null keys, append those keys to prefix and traverse them&lt;/p&gt;
&lt;p&gt;We start the call at the root with an empty list.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s an implementation:&lt;/p&gt;
&lt;script src="https://gist.github.com/rgantt/61c1049eb7b650e32043.js?file=traverse.java"&gt;&lt;/script&gt;&lt;p&gt;In order to ensure that we are getting the keys back in alphabetical order, we perform a pre-order traversal.&lt;/p&gt;
&lt;h2&gt;Time complexity&lt;/h2&gt;
&lt;p&gt;Like mentioned previously, prefix trees are well suited to lookups on string keys. Let&amp;#8217;s walk through an example.&lt;/p&gt;
&lt;p&gt;Assume that we have a well-populated tree with many overlapping keys. Now we call &lt;code&gt;get&lt;/code&gt; with key &lt;code&gt;"cab"&lt;/code&gt;, which exists in the trie. Working our way through the algorithm implemented above, we will look for the child of the root node that has the key &lt;code&gt;c&lt;/code&gt;. In our implementation, this lookup happens in &lt;code&gt;O(log c)&lt;/code&gt; time (because of our choice of &lt;code&gt;TreeMap&lt;/code&gt; instead of &lt;code&gt;HashMap&lt;/code&gt; to take advantage of the ordering property of binary trees), where &lt;code&gt;c&lt;/code&gt; is the number of characters in the tree; this is at most 26. Note that if we used a &lt;code&gt;HashMap&lt;/code&gt; or array instead, this lookup would happen in &lt;code&gt;O(1)&lt;/code&gt; time. For small &lt;code&gt;c&lt;/code&gt; this is hardly worth mentioning.&lt;/p&gt;
&lt;p&gt;The time complexity we are interested in, though, is not a function of the number of children of a given node, but a function of the number of words mapped in the trie itself. The &lt;code&gt;O(log c)&lt;/code&gt; lookup mentioned above occurs once for each character in the string key. So the lookup time is directly proportional to the length of the string, but effectively constant in terms of the number of elements mapped in the trie&amp;#8212;&lt;code&gt;O(1)&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Final thoughts&lt;/h2&gt;
&lt;p&gt;Prefix trees are a nice data structure that&amp;#8217;s especially tailored for mapping words to values. You get all of the benefits of the map type interface, and none of the costs of collisions that are inevitable as the number of mappings a hash table stores increases.&lt;/p&gt;
&lt;h3&gt;Implementation trade-offs&lt;/h3&gt;
&lt;p&gt;1. How would the time complexity change if we used a data structure other than a &lt;code&gt;TreeMap&lt;/code&gt; to store a node&amp;#8217;s children? Under what circumstances is that trade-off worth making?&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href="https://gist.github.com/rgantt/5711830"&gt;Complete implementation (including unit tests) of this example&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href="https://github.com/rgantt/jsterbate/blob/master/lib/trie.js"&gt;Implementation of a prefix tree in Javascript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
    <summary type="html">One common implementation of the map abstract data type, a hash table, provides fast lookup, insertion, and deletion. Unfortunately, data stored in a hash table makes no guarantee about order. Even binary tree-based implementations, with their natural sorting, are not optimized around sorting stored data. Prefix trees (tries) provide a trade-off between insertion, deletion, and sorting speed by breaking up data into smaller chunks and allowing nodes to have many children. By doing this, they offer a convenient representation of strings that can be easily used in applications like spellcheck and auto-complete.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-08-22:/articles/php-class-traits/</id>
    <title type="html">Horizontal reusability with traits</title>
    <published>2011-08-22T07:00:00Z</published>
    <updated>2011-08-22T07:00:00Z</updated>
    <author>
      <name>Ryan</name>
      <uri>http://www.zuttonet.com</uri>
    </author>
    <link rel="alternate" href="http://www.zuttonet.com/articles/php-class-traits/"/>
    <content type="html">&lt;p&gt;The ability for a class to inherit from multiple parents is maligned by many, but can be a good thing in some situations. For those working in &lt;span class="caps"&gt;PHP&lt;/span&gt;, multiple inheritance has never been an option; classes are limited to one parent, though they can implement many other datatypes through the use of interfaces. Interfaces can lead to code duplication in improperly-factored inheritance hierarchies. Even in well-architected hierarchies, multiple classes that implement similar methods can contain a lot of overlap.&lt;/p&gt;
&lt;p&gt;To address these concerns, &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.4 includes a new feature called &lt;em&gt;traits&lt;/em&gt; which allow us to do something that seems an awful lot like multiple inheritance at first glance. Traits allow &lt;span class="caps"&gt;PHP&lt;/span&gt; classes to be &amp;#8220;extended&amp;#8221; &lt;em&gt;horizontally&lt;/em&gt;, rather than vertically. In other words, we can use traits to write methods once and use them in multiple classes, without the multiple inheritance consequence of adding more explicit type information to the classes we modify.&lt;/p&gt;
&lt;h2&gt;What traits are&lt;/h2&gt;
&lt;p&gt;A trait is very similar to a class. It is a collection of methods along with a specific notion of state. Traits use the state of the instance of a class into which they&amp;#8217;re inserted; they have access to &lt;code&gt;$this&lt;/code&gt;. Their use allows methods to be injected into a class at run time. Traits allow you to define a method and then use it in &lt;em&gt;multiple classes&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There are four main differences between a class and a trait:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;A trait cannot be instantiated&lt;/li&gt;
	&lt;li&gt;A trait &lt;em&gt;should&lt;/em&gt; avoid the creation of additional state&lt;/li&gt;
	&lt;li&gt;A trait cannot implement an interface &lt;del&gt;but it can extend a class&lt;/del&gt; &lt;em&gt;or&lt;/em&gt; extend a class&lt;/li&gt;
	&lt;li&gt;A trait has no specific type &lt;del&gt;even if it has a parent class&lt;/del&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(A note on the above: the first alpha release of &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.4 allowed traits to extend classes. Since there are no useful semantics associated with this feature, it&amp;#8217;s been &lt;a href="https://bugs.php.net/bug.php?id=55524"&gt;written up as a defect&lt;/a&gt; and will be corrected in the next release.)&lt;/p&gt;
&lt;p&gt;Number 2 is important, because traits are not intended to be a replacement for classes. As soon as traits contain methods along with properties, they begin to resemble non-instantiable classes. In the current release, properties &lt;em&gt;are&lt;/em&gt; allowed within traits, but there is no formal provision for handling such state in the &lt;span class="caps"&gt;RFC&lt;/span&gt; &amp;#8220;specification.&amp;#8221; It&amp;#8217;s probably a good thing to avoid trait properties.&lt;/p&gt;
&lt;p&gt;Traits can&amp;#8217;t do things that classes do, so why even bother? The good part isn&amp;#8217;t their limitation relative to classes, but how they can &lt;em&gt;augment&lt;/em&gt; classes&amp;#8217; capabilities. Here are some reasons why traits are even worth bothering with:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;traits allow methods to be written once and injected into multiple, &lt;em&gt;derived&lt;/em&gt; classes&lt;/li&gt;
	&lt;li&gt;traits allow class functionality to be extended&lt;/li&gt;
	&lt;li&gt;traits can be composed&amp;#8212;in other words, a trait may consist of other traits&lt;/li&gt;
	&lt;li&gt;classes can use multiple traits&lt;/li&gt;
	&lt;li&gt;classes can modify trait method visibility but not &lt;em&gt;vice versa&lt;/em&gt;&lt;/li&gt;
	&lt;li&gt;classes can refer to trait method names using aliases&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In a lot of ways, using a trait is like telling the interpreter to copy and paste source code from that trait into any number of classes. Some even refer to it as &amp;#8220;compiler-assisted copy and paste.&amp;#8221; If that&amp;#8217;s how you want to think of it, then go for it. Just keep in mind that it&amp;#8217;s not &lt;em&gt;exactly&lt;/em&gt; a copy/paste procedure, as I explain below.&lt;/p&gt;
&lt;p&gt;Here follow two situations involving code duplication that can be remedied by traits. The first gives a good motivation on traits in general for those who are unfamiliar.&lt;/p&gt;
&lt;h1&gt;A divergent hierarchy&lt;/h1&gt;
&lt;p&gt;Say you&amp;#8217;re in a situation where you must implement two nephew classes to extend a class hierarchy. For the sake of clarity, imagine that you&amp;#8217;re working with a simple hierarchy like the one in the image below. At the head, you&amp;#8217;ve got &lt;code&gt;Super&lt;/code&gt;, from which all other classes will inherit. Below that, &lt;code&gt;Sub1&lt;/code&gt; and &lt;code&gt;Sub2&lt;/code&gt; contain some functionality useful to you, but both need to be extended. So you create your own subclasses, &lt;code&gt;MySub1&lt;/code&gt; and &lt;code&gt;MySub2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/articles/traits/basic.png" alt="" /&gt;&lt;/p&gt;
&lt;h2&gt;Code duplication&lt;/h2&gt;
&lt;p&gt;Somewhere along the way, you realize how great it would be if both classes performed the same action&amp;#8212;call it &lt;code&gt;someFunction&lt;/code&gt;. Your hierarchy now looks something like the following:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/articles/traits/duplication.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;At first, you write &lt;code&gt;someFunction&lt;/code&gt; once and stick it in &lt;code&gt;MySub1&lt;/code&gt;. After you&amp;#8217;re satisfied that it behaves how you expect, you copy and paste its source into &lt;code&gt;MySub2&lt;/code&gt;. Your tests pass; then, the full weight of what you&amp;#8217;ve just done hits you like a train.&lt;/p&gt;
&lt;p&gt;The code on your screen looks something like the following:&lt;/p&gt;
&lt;script src="https://gist.github.com/1155168.js?file=duplicate-code-in-subclasses.php"&gt;&lt;/script&gt;&lt;p&gt;You can&amp;#8217;t just leave it like this. Code duplication is bad. What&amp;#8217;s your next move?&lt;/p&gt;
&lt;h3&gt;Classical inheritance&lt;/h3&gt;
&lt;p&gt;Because you already have a well-defined inheritance hierarchy, you should be able to push the duplicated functionality upward to the nearest common ancestor of the two classes. In other words, you&amp;#8217;d like to refactor &lt;code&gt;someFunction&lt;/code&gt; out of &lt;code&gt;MySub1&lt;/code&gt; and &lt;code&gt;MySub2&lt;/code&gt; and into &lt;code&gt;Super&lt;/code&gt;. If you have the ability to modify &lt;code&gt;Super&lt;/code&gt;, this is probably the right thing to do.&lt;/p&gt;
&lt;p&gt;After the refactoring, your class hierarchy will look like this:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/articles/traits/inheritance.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s an example of the code representing this change:&lt;/p&gt;
&lt;script src="https://gist.github.com/1155168.js?file=refactor-into-superclass.php"&gt;&lt;/script&gt;&lt;p&gt;What about in a situation where you are unable to modify the class definitions that you&amp;#8217;re using? When working with existing frameworks, this can often be the case. You can&amp;#8217;t always just go into a superclass and make changes. This is one situation where it might be nice to use a trait.&lt;/p&gt;
&lt;h3&gt;Horizontal composition with traits&lt;/h3&gt;
&lt;p&gt;If we can&amp;#8217;t move &lt;code&gt;someFunction&lt;/code&gt; up, then let&amp;#8217;s move it to the side. Defining a new trait that includes the definition of &lt;code&gt;someFunction&lt;/code&gt;&amp;#8212;which is common to both &lt;code&gt;MySub1&lt;/code&gt; and &lt;code&gt;MySub2&lt;/code&gt; allows us to sidestep the file permissions issue. Instead, create a chunk of reusable functionality that can be injected into more than one class.&lt;/p&gt;
&lt;p&gt;The same problem as above, this time solved by traits, looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/articles/traits/trait.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;Hierarchicaly, this looks very similar to the original solution. However, we no longer have any duplication because the definition of &lt;code&gt;someFunction&lt;/code&gt; has been moved into &lt;code&gt;MyTrait&lt;/code&gt;. Now the nephew classes can simply &lt;code&gt;use MyTrait&lt;/code&gt; and have &lt;code&gt;someFunction&lt;/code&gt; injected into their definitions:&lt;/p&gt;
&lt;script src="https://gist.github.com/1155168.js?file=use-trait-for-duplication.php"&gt;&lt;/script&gt;&lt;p&gt;Traits promote horizontal composition because they allow specific pieces of functionality to be injected into any number of classes both without duplication and without respect for the classes&amp;#8217; derived types. Classical inheritance pushes functionality down through a hierarchy, while traits can be used to shove functionality sideways into a hierarchy.&lt;/p&gt;
&lt;h2&gt;Traits aren&amp;#8217;t &lt;em&gt;exactly&lt;/em&gt; copypasta&lt;/h2&gt;
&lt;p&gt;Earlier, I said that you could think of traits as chunks of code that are simply copied and pasted into whatever classes use them. While this is a useful mental model, it&amp;#8217;s not exactly right.&lt;/p&gt;
&lt;p&gt;To illustrate this, consider the following example which will result in a fatal error when executed. One cannot declare a method prototype with the &lt;code&gt;abstract&lt;/code&gt; modifier and then implement that method in the same class. &lt;code&gt;abstract&lt;/code&gt; enforces the implementation of some method in a &lt;em&gt;lower&lt;/em&gt; class.&lt;/p&gt;
&lt;script src="https://gist.github.com/1155168.js?file=abs-fatal.php"&gt;&lt;/script&gt;&lt;p&gt;If @use@ing a trait were identical to copying and pasting code, then the following gist should fail exactly the same way.&lt;/p&gt;
&lt;script src="https://gist.github.com/1155168.js?file=abs-trait-no-problem.php"&gt;&lt;/script&gt;&lt;p&gt;Executing it, however, does not result in a fatal error. Compilation finishes cleanly and &lt;code&gt;"anything"&lt;/code&gt; is shown on the screen.&lt;/p&gt;
&lt;p&gt;The reason for this is that the &lt;code&gt;abstract&lt;/code&gt; keyword means something slightly different in the context of a trait. Classes use &lt;code&gt;abstract&lt;/code&gt; to push responsibility down the chain; traits use it to enforce a contract with their includer. This is really straddling the line between &amp;#8220;horizontal reusability&amp;#8221; and multiple inheritance.&lt;/p&gt;
&lt;h2&gt;Implementation constraints in traits&lt;/h2&gt;
&lt;p&gt;Maybe you&amp;#8217;ve written a trait that does something with a database connection or file handle. Ideally you would handle some specific, non state-dependent piece of the algorithm with the trait; state-dependent things should be left to classes. To enforce this, you might make a call in your trait to a method that the includer is required to define.&lt;/p&gt;
&lt;p&gt;For example, say you call &lt;code&gt;getFileHandle&lt;/code&gt; in one of your trait methods. If the class using this trait does not have a &lt;code&gt;getFileHandle&lt;/code&gt; method defined somewhere in its hierarchy, you are going to get a runtime fatal error. If instead you modify your trait to include an &lt;code&gt;abstract&lt;/code&gt; prototype for this method, you can bubble the runtime error up to a compilation error. &lt;span class="caps"&gt;PHP&lt;/span&gt; simply won&amp;#8217;t allow you to use a trait unless you&amp;#8217;ve satisfied its method contract. See how similar this is to multiple inheritance?&lt;/p&gt;
&lt;h1&gt;Distinct hierarchies&lt;/h1&gt;
&lt;p&gt;There are other situations in which it might make sense to use a trait.&lt;/p&gt;
&lt;h2&gt;Adding logging capabilities to a class&lt;/h2&gt;
&lt;p&gt;Adding tracing and logging functionality to a class is very common. Using a trait, we can wrap up all of the initialization and file-handling code into a reusable block and plug it into whatever class we prefer.&lt;/p&gt;
&lt;script src="https://gist.github.com/1155168.js?file=logging-trait.php"&gt;&lt;/script&gt;&lt;p&gt;Dave Marshall provides another implementation of a Logging trait in &lt;a href="http://www.davedevelopment.co.uk/2011/08/06/traits-in-php-5-4-helloworld-with-logging-trait/"&gt;this article&lt;/a&gt;. The primary differences are that my pseudo Logging trait requires no external state (thanks to the way static local variables work in method bodies) and I skip the detail of providing an actual logger. Details, details!&lt;/p&gt;
&lt;h2&gt;Turning a class into a Singleton&lt;/h2&gt;
&lt;p&gt;There are other situations where it is desirable to have horizontal reuse. What if we find that duplication is happening across disjoint hierarchies? It&amp;#8217;s not inconceivable that two classes might do something similar or be used in a similar way.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s construct an example where we have multiple classes into which we would like to inject Singleton* functionality:&lt;/p&gt;
&lt;script src="https://gist.github.com/1155168.js?file=singleton-trait.php"&gt;&lt;/script&gt;&lt;h2&gt;Parting thoughts&lt;/h2&gt;
&lt;p&gt;Traits are an exciting new feature coming our way in &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.4. Since 5.4 is still in alpha, it&amp;#8217;s difficult to say what exact features will make it to the stable release. There are several quirks and features not mentioned in this article, but my goal was simply to explain the feature at a high enough level that the exact implementation details at release could be easily understood.&lt;/p&gt;
&lt;h2&gt;Additional resources&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href="https://wiki.php.net/rfc/horizontalreuse"&gt;&lt;span class="caps"&gt;PHP&lt;/span&gt; horizontal reuse &lt;span class="caps"&gt;RFC&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href="http://php.net/manual/en/language.oop5.traits.php"&gt;&lt;span class="caps"&gt;PHP&lt;/span&gt; Manual: Traits&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href="http://news.ycombinator.com/item?id=1924442"&gt;Hacker news discussion about Traits&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href="http://www.davedevelopment.co.uk/2011/08/06/traits-in-php-5-4-helloworld-with-logging-trait/"&gt;HelloWorld with Logging trait&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href="http://blogs.msdn.com/b/scottdensmore/archive/2004/05/25/140827.aspx"&gt;Why Singletons are Evil&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
    <summary type="html">Although PHP allows classes to implement more than one interface, it does not support multiple inheritance. Lack of multiple inheritance can lead to code duplication in certain situations, which is contrary to the goals of reusable object-oriented programming. Here I explore a couple of these situations and traits, a new language-level feature in PHP 5.4 that has been added to address this concern.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-08-08:/articles/anonymous-recursion-php/</id>
    <title type="html">Anonymous recursion in PHP</title>
    <published>2011-08-08T07:00:00Z</published>
    <updated>2011-08-08T07:00:00Z</updated>
    <author>
      <name>Ryan</name>
      <uri>http://www.zuttonet.com</uri>
    </author>
    <link rel="alternate" href="http://www.zuttonet.com/articles/anonymous-recursion-php/"/>
    <content type="html">&lt;h2&gt;The scenario&lt;/h2&gt;
&lt;p&gt;You&amp;#8217;re neck deep in 3-year old production code, amazon one-click checkout isn&amp;#8217;t working, and your wife just left you for someone who &amp;#8220;doesn&amp;#8217;t spend so much time writing unit tests.&amp;#8221; You need to save the world by implementing an algorithm using an anonymous function &lt;em&gt;now&lt;/em&gt;. Wait, what if the problem you need to solve is well served with a recursive approach? Maybe you attack the problem optimistically, starting with something like this:&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=super-naive-approach.php"&gt;&lt;/script&gt;&lt;p&gt;&amp;#8220;Well, crap,&amp;#8221; you say, seeing the &lt;code&gt;Fatal error&lt;/code&gt; reported by &lt;span class="caps"&gt;PHP&lt;/span&gt;. Turns out that variables called as functions must be an instance of &lt;code&gt;Closure&lt;/code&gt;, an instance of a class which implements &lt;code&gt;__invoke()&lt;/code&gt;, or a string representing a named function in the global namespace. In the anonymous function body above, &lt;code&gt;$fibonacci&lt;/code&gt; is none of these. It is an undeclared, free variable in the closure created by the anonymous function. At the time when it&amp;#8217;s called, it hasn&amp;#8217;t been bound&amp;#8212;hence the &lt;code&gt;Notice&lt;/code&gt; that you would have gotten if error reporting were set at a high enough threshold&amp;#8212;and therefore can&amp;#8217;t be called as &lt;em&gt;anything&lt;/em&gt;, let alone as a function.&lt;/p&gt;
&lt;p&gt;So how should you proceed? The classical solution would be simply to name this function; instead of binding the function to a variable called &lt;code&gt;$fibonacci&lt;/code&gt;, we should just &lt;em&gt;name&lt;/em&gt; the function &lt;code&gt;fibonacci&lt;/code&gt;. That would certainly be convenient. But what if we encounter a higher-order function that expects a function as a parameter? It happens that many higher-order functions in &lt;span class="caps"&gt;PHP&lt;/span&gt; can simply accept as callbacks the names of functions, but I prefer not to rely on that. In fact, any userland function you write which expects a lambda will work just as happily being sent a string. But what if we &lt;strong&gt;must&lt;/strong&gt; provide the higher-order function with the means of calculating the nth Fibonacci number? How could we even go about implementing the recursion required to pull it off? I&amp;#8217;m so glad you asked.&lt;/p&gt;
&lt;h2&gt;Naming the nameless&lt;/h2&gt;
&lt;p&gt;The difficult part about the above is that we have no good way to actually call the function in whose body we are executing while we&amp;#8217;re still in it. The thing&amp;#8217;s anonymous, after all&amp;#8212;we are essentially looking for some way to break its anonymity, to call the nameless by name. Well, we may not be able to actually extract the name of this function for the purpose of calling it again, but we do have some information about the location where it&amp;#8217;s held in memory. This location is known to &lt;code&gt;$fibonacci&lt;/code&gt;, the value we&amp;#8217;re using in the parent scope to hold the function itself. Therefore, if we could grab the value of &lt;code&gt;$fibonacci&lt;/code&gt;, we could actually use it to recurse. The problem here is that &lt;code&gt;$fibonacci&lt;/code&gt; does not exist in the scope where we need to use it.&lt;/p&gt;
&lt;p&gt;If you had read my &lt;a href="http://zuttonet.com/articles/anonymous-functions-and-closure-php/"&gt;article about closures&lt;/a&gt;, you would know that we have the ability in &lt;span class="caps"&gt;PHP&lt;/span&gt; to do something that sounds very much like this. With PHP&amp;#8217;s &lt;code&gt;use&lt;/code&gt; keyword for anonymous function definition, we can pull either a value or a reference into a function&amp;#8217;s scope. Let&amp;#8217;s be naive and pull in the &lt;em&gt;value&lt;/em&gt; of &lt;code&gt;$fibonacci&lt;/code&gt; in a forshadowingly misguided attempt to recurse:&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=naive-closure-approach.php"&gt;&lt;/script&gt;&lt;p&gt;This new function actually has the exact same body as our original attempt; the only difference is that we are now pulling in the value of &lt;code&gt;$fibonacci&lt;/code&gt; from the parent scope and binding it at definition-time. Running this, we actually get the exact same error we got above. Why?&lt;/p&gt;
&lt;p&gt;Without going into the nitty gritty details, let&amp;#8217;s walk through what&amp;#8217;s happening here. First, we declare a variable called &lt;code&gt;$fibonacci&lt;/code&gt; and then assign to it the anonymous function. Here&amp;#8217;s the problem: this function statement doesn&amp;#8217;t terminate until &lt;em&gt;after&lt;/em&gt; the value of &lt;code&gt;$fibonacci&lt;/code&gt; is pulled into its body and used. Since we are @use@ing &lt;code&gt;$fibonacci&lt;/code&gt; by value, that value is declared but undefined when we actually pull it into the function scope. Notice that there is no fatal error here &lt;em&gt;until&lt;/em&gt; we actually execute &lt;code&gt;$fibonacci()&lt;/code&gt;. That&amp;#8217;s very important.&lt;/p&gt;
&lt;h2&gt;Closure-by-reference&lt;/h2&gt;
&lt;p&gt;Seeing that this doesn&amp;#8217;t work, let&amp;#8217;s take a slightly different approach by bringing &lt;code&gt;$fibonacci&lt;/code&gt; into the anonymous function by reference (in functional parlance, let&amp;#8217;s close our anonymous function over &lt;code&gt;$fibonacci&lt;/code&gt;). By doing so, we still pull &lt;code&gt;$fibonacci&lt;/code&gt; into our function before it actually refers to anything useful. However, because we are closing by reference, rather than by value, &lt;code&gt;$fibonacci&lt;/code&gt; will be properly defined by the time we actually need to run it. Remember how we didn&amp;#8217;t get the error by value until we executed the function? That problem goes away now, because by the time we execute the function, the variable holding it for us is &lt;em&gt;actually&lt;/em&gt; holding it for us.&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=closure-by-reference.php"&gt;&lt;/script&gt;&lt;p&gt;Now that we have a working recursive anonymous function, let&amp;#8217;s explore some examples of what we can do with it. One nice thing about this particular implementation (which emphatically isn&amp;#8217;t due to its anonymous nature, but rather by design) is that it is completely non-destructive.&lt;/p&gt;
&lt;h2&gt;Applications&lt;/h2&gt;
&lt;p&gt;Here are some applications of what we&amp;#8217;ve accomplished above:&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;map&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;Functional programming in &lt;span class="caps"&gt;PHP&lt;/span&gt; is a whole &amp;#8216;nother level of ugly. Here&amp;#8217;s an implementation of &lt;code&gt;map&lt;/code&gt;, a higher-order function which takes a single-argument function and applies it to each element in a collection. Here, we pass it &lt;code&gt;$fibonacci&lt;/code&gt;, which holds our recursive anonymous function.&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=php-library-map.php"&gt;&lt;/script&gt;&lt;h3&gt;&lt;code&gt;reduce&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt; is another common higher-order function. It takes a function of two arguments and a collection and maps the array pairwise into a single value using the function.&lt;/p&gt;
&lt;script src="https://gist.github.com/1134355.js?file=php-library-reduce.php"&gt;&lt;/script&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If we were in a situation where we needed to make use of a higher-order function like one of these above, it would be very inconvenient to be limited to only using anonymous functions which could not be written recursively. With these &amp;#8220;pass-by-reference closures&amp;#8221; in &lt;span class="caps"&gt;PHP&lt;/span&gt;, we can circumvent that limitation and provide our anonymous function to any higher-order function that can use it.&lt;/p&gt;
&lt;p&gt;This is still a somewhat poor solution, however, because our functions are no longer truly anonymous. Instead of binding the name of the function to an identifier, we are binding the name of our function to a variable. In case we wanted to change the name of the function, or provide recursion like this in an inner-anonymous function, we might struggle.&lt;/p&gt;</content>
    <summary type="html">I've been working toward building a useful set of concepts to apply some functional programming techniques in PHP 5.3. Yes, _functional_ programming in PHP. In this article, I explore the concept of anonymous recursion, something that becomes important in situations where we are using anonymous functions to solve problems that are well suited to a recursive approach.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-07-15:/articles/anonymous-functions-and-closure-php/</id>
    <title type="html">Anonymous functions and closure in PHP</title>
    <published>2011-07-15T07:00:00Z</published>
    <updated>2011-07-15T07:00:00Z</updated>
    <author>
      <name>Ryan</name>
      <uri>http://www.zuttonet.com</uri>
    </author>
    <link rel="alternate" href="http://www.zuttonet.com/articles/anonymous-functions-and-closure-php/"/>
    <content type="html">&lt;p&gt;&lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3 introduced function literals to the language, providing big benefits in the form of syntax and readability when using and creating functions that accept other functions as arguments. However, the introduction of &lt;a href="http://php.net/manual/en/functions.anonymous.php"&gt;anonymous functions&lt;/a&gt; was paired with another useful language construct which allows us to close over local variables in the same scope as the anonymous function, creating a closure.&lt;/p&gt;
&lt;h2&gt;What is closure?&lt;/h2&gt;
&lt;p&gt;According to Wikipedia, a &lt;strong&gt;closure&lt;/strong&gt; is a&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;function together with a referencing environment for the nonlocal names (free variables) of that function&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A closure is so-called because it is &lt;em&gt;closed over&lt;/em&gt; its free variables. These free variables, or &lt;em&gt;upvalues&lt;/em&gt;, come from the enclosing scope of the anonymous function and persist even after that scope, and all references to it, is otherwise made unavailable (e.g., by the function execution completing and returning control back to the previous frame).&lt;/p&gt;
&lt;p&gt;What does this mean for you, as a &lt;span class="caps"&gt;PHP&lt;/span&gt; developer? If you&amp;#8217;re only using vanilla functions to read in and act upon or modify global variables, then probably not much. You can already do something functionally &lt;em&gt;similar&lt;/em&gt; (emphasis) to this using the much-maligned &lt;a href="http://us.php.net/manual/en/language.variables.scope.php#language.variables.scope.global"&gt;&lt;code&gt;global&lt;/code&gt; keyword&lt;/a&gt; to import variable references from the global scope. However, when working somewhere other than the global scope&amp;#8212;or when using anonymous functions&amp;#8212;closures are a powerfully expressive means for performing many otherwise tedious and complicated tasks.&lt;/p&gt;
&lt;h2&gt;What isn&amp;#8217;t closure?&lt;/h2&gt;
&lt;p&gt;First, let&amp;#8217;s walk through an example of using the &lt;code&gt;global&lt;/code&gt; keyword in a function defined in the global namespace as a basis for comparison against the closures we&amp;#8217;ll talk about momentarily.&lt;/p&gt;
&lt;h3&gt;The &lt;code&gt;global&lt;/code&gt; keyword&lt;/h3&gt;
&lt;p&gt;Suppose you are writing a function that, for some &lt;em&gt;good&lt;/em&gt; reason, requires you to change a variable defined outside of the function&amp;#8217;s scope. We can import the variable from the global scope into the function scope using the &lt;code&gt;global&lt;/code&gt; keyword, like so:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=basic-global.php"&gt;&lt;/script&gt;&lt;p&gt;The output of this script would be &lt;code&gt;1&lt;/code&gt;. The &lt;code&gt;global&lt;/code&gt; keyword imports a reference to the global variable &lt;code&gt;$count&lt;/code&gt;, whose value at that time is &lt;code&gt;0&lt;/code&gt;, into the function scope. The global variable itself is then incremented. Because we have imported and incremented a reference, this function actually modifies something in the global namespace.&lt;/p&gt;
&lt;p&gt;A naive reading of the definition of &lt;em&gt;closure&lt;/em&gt; above might lead one to think that this fits the bill. However, the implementation details are slightly different; &lt;span class="caps"&gt;PHP&lt;/span&gt; has a &lt;a href="http://us.php.net/manual/en/language.variables.superglobals.php"&gt;superglobal&lt;/a&gt; variable named &lt;code&gt;$GLOBALS&lt;/code&gt; that is accessible from within any scope. The &lt;code&gt;global $var&lt;/code&gt; construct is simply syntactic sugar for the much uglier &lt;code&gt;$var = &amp;amp;$GLOBALS['var'];&lt;/code&gt; expression, which would have the same effect. Because this is simply a reference to a superglobal, we could in principle observe manipulation of this variable from another source, outside of the function. This is not closure.&lt;/p&gt;
&lt;h3&gt;Scope within a scope&lt;/h3&gt;
&lt;p&gt;Another reason this does not create closure is due to the fact that, no matter within which scope you currently operate, &lt;code&gt;global&lt;/code&gt; imports only references from the &lt;em&gt;global&lt;/em&gt; namespace (due to the implementation reality outlined above). For example, a function within a function cannot import scope from its parent using &lt;code&gt;global&lt;/code&gt;, but only from the global namespace.&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=global-inner-function.php"&gt;&lt;/script&gt;&lt;p&gt;Running the program above will output &lt;code&gt;1 1&lt;/code&gt; (no spaces). This shows that &lt;code&gt;global&lt;/code&gt; imports variables only from the global namespace, not just from the &amp;#8220;parent&amp;#8221; namespace. Closure would require either the &lt;code&gt;global&lt;/code&gt; statement to grab from the next-highest namespace, or simply allow the parent scope to creep into the child scope (another style of scoping entirely, a la javascript). This is not closure.&lt;/p&gt;
&lt;h3&gt;Anonymous functions&lt;/h3&gt;
&lt;p&gt;Is an anonymous function a closure, then? Anonymous functions and closures are often conflated, but they are distinct concepts. I think the garden path I&amp;#8217;ve been leading you on so far should have steered you away from this, but let&amp;#8217;s just make sure. We know that simply using &lt;code&gt;global&lt;/code&gt; isn&amp;#8217;t closure because of its implementation-that it doesn&amp;#8217;t actually close over variables within the function-defining scope, it just brings them into the current scope by reference. Anonymous functions are still functions, and &lt;code&gt;global&lt;/code&gt; operates within them the same way it operates within named functions. Anonymous functions are not closures.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m unclear on the low-level implementation details of functions versus anonymous functions in &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3, but there is no practical difference in terms of the ostensible constraints they face in terms of scope, input, and output. For example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=function-literal-global.php"&gt;&lt;/script&gt;&lt;p&gt;The only meaningful difference here is that &lt;code&gt;increase_count&lt;/code&gt; is given a name at define-time, while &lt;code&gt;$increase_count_again&lt;/code&gt; is assigned a function literal which is executed by variable name at run time. They both face the same rules &lt;em&gt;vis-a-vis&lt;/em&gt; &lt;code&gt;global&lt;/code&gt;, and the fact that this script outputs &lt;code&gt;2&lt;/code&gt; is proof of that.&lt;/p&gt;
&lt;h2&gt;The &lt;code&gt;use&lt;/code&gt; keyword&lt;/h2&gt;
&lt;p&gt;So what is closure? You&amp;#8217;ve been reading long enough now that you might suspect I&amp;#8217;ve eliminated every possible misconception and misunderstanding that could possible arise. That&amp;#8217;s not true; closure is a difficult concept to grasp, and misunderstanding it can lead to misuse, which can introduce hard-to-detect bugs.&lt;/p&gt;
&lt;p&gt;Closure requires both a function, with its own scope, and a surrounding environment which persists through an arbitrary number of executions of that function. So, an anonymous function is insufficient. In order to produce a closure, we need to be able to create the surrounding environment. Luckily, &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3 also introduced a very useful construct for turning anonymous functions into closures.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;use&lt;/code&gt; by value&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;use&lt;/code&gt; keyword, when paired with a function literal&amp;#8212;or anonymous function&amp;#8212;allows us to import variable values or references into the scope of the function. Here&amp;#8217;s an example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=simple-naive-closure-value.php"&gt;&lt;/script&gt;&lt;p&gt;We use &lt;code&gt;$count&lt;/code&gt; by value, so the output of the script is &lt;code&gt;1&lt;/code&gt;. This is because &lt;span class="caps"&gt;PHP&lt;/span&gt; binds a function-local variable named &lt;code&gt;$count&lt;/code&gt; to the value of the parent-local &lt;code&gt;$count&lt;/code&gt; at the time the function literal is defined. Even if we change the value of the parent-local &lt;code&gt;$count&lt;/code&gt; (say, by incrementing it between defining &lt;code&gt;$decrease_count&lt;/code&gt; and calling it), its value within the function body will not change. This also implies that changing &lt;code&gt;$count&lt;/code&gt; in the function-local scope will have no effect on the value of &lt;code&gt;$count&lt;/code&gt; in the parent-local scope. This is not closure.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;use&lt;/code&gt; by reference&lt;/h3&gt;
&lt;script src="https://gist.github.com/1084089.js?file=simple-naive-closure-reference.php"&gt;&lt;/script&gt;&lt;p&gt;I keep using the phrase &amp;#8220;by value or reference&amp;#8221; because either is possible. Notice in the example above that I have prefixed &lt;code&gt;$count&lt;/code&gt; with &lt;code&gt;&amp;amp;&lt;/code&gt;, the &lt;span class="caps"&gt;PHP&lt;/span&gt; symbol that makes an assignment &lt;a href="http://php.net/manual/en/language.references.pass.php"&gt;by reference&lt;/a&gt;. The output of the above script is as expected: &lt;code&gt;$count&lt;/code&gt; from the parent-local scope is decremented in the function-local scope and the printed result is &lt;code&gt;0&lt;/code&gt;. Notice especially that this particular script need not be defined in the global namespace (the file in which it&amp;#8217;s defined could be included in a function, for example); &lt;code&gt;use&lt;/code&gt; always refers to the scope in which the function is defined. This is closure.&lt;/p&gt;
&lt;p&gt;More basically, you might ask: how is this any different from using &lt;code&gt;global&lt;/code&gt; inside a function defined in the global namespace? The most important way is that it allows us to import a value or reference from the immediate-parent scope, not just the global scope. The tuple following the &lt;code&gt;use&lt;/code&gt; keyword tells &lt;span class="caps"&gt;PHP&lt;/span&gt; to import values or references to each element into the function scope.&lt;/p&gt;
&lt;p&gt;Ok, so you can import variables by reference into anonymous functions. What&amp;#8217;s the big deal? Well, now that you understand many of the things that &lt;em&gt;aren&amp;#8217;t&lt;/em&gt; closure (and have an example of something that technically &lt;em&gt;is&lt;/em&gt; closure), let&amp;#8217;s see what you can do with it.&lt;/p&gt;
&lt;h2&gt;Usage of closure&lt;/h2&gt;
&lt;p&gt;Under usual circumstances and in many languages, any variable allocated within a function body is lost when that function&amp;#8217;s execution is completed, because the frame containing it is popped (although this &lt;a href="http://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope"&gt;isn&amp;#8217;t exactly right in all languages&lt;/a&gt;). Within a closure, however, we can maintain and manipulate the information created inside of an enclosing function even after that enclosing function has finished execution. Check out the following example:&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=full-closure-count.php"&gt;&lt;/script&gt;&lt;p&gt;In this script, the body of the &lt;code&gt;create_closure&lt;/code&gt; function has a local variable named &lt;code&gt;$count&lt;/code&gt;. &lt;code&gt;create_closure&lt;/code&gt; returns an anonymous function which has by-reference access to this local variable. Therefore, where references to @create_closure@&amp;#8217;s &lt;code&gt;$count&lt;/code&gt; would typically lose all meaning when its body was finished executing, there now remains a reference to it &lt;em&gt;within&lt;/em&gt; any variable to which the anonymous function is assigned. &lt;strong&gt;&lt;code&gt;create_closure&lt;/code&gt; creates a closure because it returns a function together with a referencing environment for the nonlocal names of that function&lt;/strong&gt;. This is closure.&lt;/p&gt;
&lt;p&gt;Notice the output of the above (shown inline as comments). We call the anonymous function three times, and the output changes each time, even though the body of the anonymous function really does nothing interesting. &lt;code&gt;$closure&lt;/code&gt; has &amp;#8220;closed over&amp;#8221; &lt;code&gt;$count&lt;/code&gt; and now has local access to it for any call to &lt;code&gt;$closure()&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;More advanced usage&lt;/h2&gt;
&lt;p&gt;What if we generate multiple closures; how is this handled? I&amp;#8217;m so glad you asked.&lt;/p&gt;
&lt;script src="https://gist.github.com/1084089.js?file=full-closure-count-2.php"&gt;&lt;/script&gt;&lt;p&gt;We now create two different closures. You noticed, of course, that the function generating the closures is parameterized by &lt;code&gt;$count&lt;/code&gt;. Since we call this function twice&amp;#8212;each time with a different parameter value&amp;#8212;it shouldn&amp;#8217;t come as a surprise that we will receive two separate closures, each closed over a different value for &lt;code&gt;$count&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Anonymous functions and closures are a very neat and powerful addition to &lt;span class="caps"&gt;PHP&lt;/span&gt; 5.3. I hope after reading this article you better understand how to use these new language features, and maybe even have a better idea of why they&amp;#8217;re a big improvement over what was previously available. This article is meant to serve as a basic introduction and overview of the language-level characteristics of closures. Let me know what you think!&lt;/p&gt;</content>
    <summary type="html">PHP 5.3 introduced function literals to the language, providing big benefits in the form of syntax and readability when using and creating functions that accept other functions as arguments. However, the introduction of anonymous functions was paired with another useful language construct which allows us to close over local variables in the same scope as the anonymous function, creating a closure.</summary>
  </entry>
  <entry>
    <id>tag:www.zuttonet.com,2011-06-13:/articles/dead-simple-profiling-in-php/</id>
    <title type="html">Simple performance profiling in PHP 5.3</title>
    <published>2011-06-13T07:00:00Z</published>
    <updated>2011-06-13T07:00:00Z</updated>
    <author>
      <name>Ryan</name>
      <uri>http://www.zuttonet.com</uri>
    </author>
    <link rel="alternate" href="http://www.zuttonet.com/articles/dead-simple-profiling-in-php/"/>
    <content type="html">&lt;p&gt;I love finding new ways to use PHP&amp;#8217;s anonymous functions. One thing that caught my attention recently is how they make it so easy to wrap scope and functionality into little packages. These packages can easily be fed to a utility function, allowing the functionality contained therein to be wrapped and modified dynamically.&lt;/p&gt;
&lt;p&gt;How nice would it be if there were a simple way to wrap up some script execution and figure out how long it takes? Or to take multiple versions of a function&amp;#8212;or class, or whatever&amp;#8212;and figure out which one runs in less time? It would be super nice. Unfortunately, I have never really run across a very &lt;em&gt;simple&lt;/em&gt; way to do that. So I wrote a function, called &lt;code&gt;profile&lt;/code&gt;, which accepts a diagnostic messge and a lambda which wrap around the code you are interested in profiling.&lt;/p&gt;
&lt;p&gt;The lambda that &lt;code&gt;profile&lt;/code&gt; takes should just be an anonymous function that contains all of the code that you&amp;#8217;re interested in profiling. It could also be a named function, or even an object that implements &lt;code&gt;__invoke&lt;/code&gt; (a functor). Just make sure that the thing you&amp;#8217;re passing as a callback contains the code you want to time.&lt;/p&gt;
&lt;script src="https://gist.github.com/1025970.js?file=profile.php"&gt;&lt;/script&gt;&lt;p&gt;All this function does is record the current time in microseconds, execute the function you passed, check the time again, and then return a string representation of the execution time. Simple enough, right!? I had a hard time finding something anywhere else that was so simple, though. Here&amp;#8217;s an example of it in action:&lt;/p&gt;
&lt;script src="https://gist.github.com/1025970.js?file=simple_test.php"&gt;&lt;/script&gt;&lt;p&gt;The world of performance profiling and optimization is now your oyster. Of course, this approach is limited by the implementation details of anonymous functions. For example: if you want to globalize variables from a broader scope to use in your callback, you&amp;#8217;ll have to import them using the &lt;code&gt;use&lt;/code&gt; keyword in the definition, creating a closure.&lt;/p&gt;
&lt;p&gt;The simple &lt;code&gt;profile&lt;/code&gt; function could be broadened a bit by wrapping the profile function up into a profiling class that would save information about various executions&amp;#8212;maybe even duplicating them and providing statistical information about those runs. The function also makes pretty bold assumptions about how information about the execution time should be packaged; this could certainly use some abstraction. Sounds like a good evening project!&lt;/p&gt;
&lt;p&gt;Edit: If you&amp;#8217;re interested in this concept at all, might find some use out of a more fully-implemented version&amp;#8212;or would like to contribute&amp;#8212;I&amp;#8217;ve made a github project that does everything in this article in a bit more deptch. &lt;a href="http://www.github.com/rgantt/rolex"&gt;Check it out!&lt;/a&gt;&lt;/p&gt;</content>
    <summary type="html">PHP's standard library makes it pretty easy to whip up a quick set of timing functions to wrap around your code. Maybe I'm jaded by ruby's blocks, but I would love to see that my profiling code is getting everything I want and _only_ those things I want. So I decided to sit down and whip up something quick and simple to alleviate my neurosis.</summary>
  </entry>
</feed>
